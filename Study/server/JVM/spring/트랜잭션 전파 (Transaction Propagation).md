트랜잭션이 어떻게 전파될것인가.
- 트랜잭션의 경계 정의
- 트랜잭션 간 관계 설정

> [!info] 주요 트랜잭션 전파 유형 
> 1. REQUIRED
>	- 현재 트랜잭션이 존재하면 해당 트랜잭션 내에서 실행되고, 없으면 새로운 트랜잭션을 시작한다.
>	- (보통 기본값으로 많이 사용됨)
> 2. REQUIRES_NEW
> 	- 항상 새로운 트랜잭션을 시작하며, 기존 트랜잭션이 있더라도 중단하고 새 트랜잭션을 시작한다.
> 3. SUPPORTS
> 	- 현재  트랜잭션이 존재하면 트랜잭션 내에서 실행되고, 없으면 트랜잭션 없이 실행된다.
> 4. NOT_SUPPORTED
> 	- 트랜잭션 없이 실행되며, 현재 트랜잭션이 존재하면 일시 중지한다.
> 5. MANDATORY
> 	- 반드시 현재 트랜잭션 내에서 실행되어야 하며, 존재하지 않으면 예외 발생
> 6. NEVER
> 	- 트랜잭션 없이 실행되며, 현재 트랜잭션이 존재하면 예외 발생
> 7. NESTED
> 	- 현재 트랜잭션이 존재하면 중첩된 트랜잭션을 시작하고, 없으면 REQUIRED와 동일하게 동작한다. 중첩된 트랜잭션은 외부 트랜잭션과 독립적으로 롤백 될 수 있다.

하나의 메서드 안에서 여러 데이터 베이스 작업을 수행할 때 각 작업을 별도의 트랜잭션을 처리하고자 한다면 REQUIREDS_NEW를 사용할 수 있다.
반면 하나의 큰 트랜잭션 안에서 모든 작업이 완료되기를 원할 때는 REQUIRED를 사용.

> 데이터 일관성을 유지하면서도, 유연한 트랜잭션 관리가 가능해진다.

## Spring 트랜잭션 전파 유형을 선택할 때 고려해야 할 요소

1. 비즈니스 요구사항
	- 작업 간의 의존성과 일관성을 유지하기 위해 어떤 전파 유형이 필요한지 고려해야한다.
2. 현재 트랜잭션 존재여부와 중첩 트랜잭션의 필요성
	- Nested 전파 유형을 사용하면 외부 트랜잭션과 독립적으로 롤백 할 수 있다.
3. 동시성 성능 고려
	- 새로운 트랜잭션을 생성하거나, 기존 트랜잭션을 중단하는 작업은 오버헤디를 증가시킬 수 있다.
4. 예외 처리 및 롤백 전략
	- 예외 발생 시 어떤 트랜잭션을 롤백할것인지 결정.
5. 트랜잭션 관리 정책

- [!] 부모 트랜잭에 예외가 전파되지 않아 의도한대로 동작하지 않을 수도 있다.

> [!question] 이러한 transaction전파 레벨이 nestjs에도 존재할까?
> Spring과 같은 트랜잭션 전파 레벨을 직접적으로제공되지는 않는다.
> ORM단에서 제공하는 transaction제어를 직접 하는 방식이다.


