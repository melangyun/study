<iframe width="560" height="315" src="https://www.youtube.com/embed/DY3sUeGu74M?si=xZT0WtgpDhY30CT2" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

# 왜 이벤트 기반 아키텍처를 선택했는가?

- 배달 시스템 복잡도 증가
	- 배달만 잘 수행하기를 기대했지만 점점 더 커져갔다
		- 알림
		- 배달시간
		- 통계
		- 쿠폰
		- etc

복잡도를 낮추고자 배달과 배달이 아닌 기능을 분리함
- 배달은 배달만 수행하자
- 대부분 기능은 배달과 `강한 일관성`을 필요로 하지 않는다

## 강한 일관성과 결과적 일관성

- 강한 일관성
	- 배달이 변경되었을 때, 관련 기능도 `동시에` 반영되어야 한다.
- 결과적 일관성 -> 이벤트를 통해서 표현 가능
	- 배달이 변경되었을 때, 관련 기능이 `언젠가` 반영되면 된다.
	- `이벤트`는 시스템에서 일어난 행위이다.

`이벤트` 는 시스템에서 일어난 행위이다.

## 이벤트는 어떤 정보를 가지고 있어야 할까?

- 마틴 파울러의 이벤트의 정의
	>captures the memory of something interesting wich affects the domain
	- 도메인에 영향을 주는 관심정보
		- 대상
		- 발생한 시간
		- 행동


- 배민에서 뽑은 이벤트의 구성요소 (행위를 표현하는 방법)
	- 대상
	- 행동
	- 정보
	- 시간

## 이벤트의 구성요소

행위를 표현하는 방법

> [!info] 배달이 A라이더에게 11시에 배차되었다

- 대상의 식별자 정보를 제공한다.
- 이미 벌어진 사건이므로 `과거`형으로 표현
- 행위와 관련된 값들을 표현한다. (주문 식별자)
	- 필요하다면 행위 외의 값도 추가 가능
- 행위가 발생한 시간 표현

```JSON
// 배달이 A라이더에게 15시에 배차되었다.
{
	"eventId": "D배달",
	"eventType": "배차완료",
	"data": {
		"state": "배차완료",
		"riderId": "A라이더"
	},
	"occurenceDateTime": "2013-11-15 15:00:00"
}
```


# 좋았던 점

- 배달 시스템에서 분리했기 때문에, 배달 시스템의 복잡도 하락
	- 요구사항이 추가되어도, 배달 시스템 복잡도에 영향이 없다
- 소비처 결합도 감소
	- 배달변경 사항을 이벤트로 파악 가능
	- 소비처가 배달 상세정보를 조회하지 않아도 됨
	(API를 통해서 다시 되묻지 않아도 되게금 설계)
- 데이터 분석
	- 도메인 히스토리 파악 용이
	- 분석 정보로 활용 가능


# 주의해야 할 점

- 이벤트 데이터 무분별한 추가 주의
	- 행위자 기반의 데이터 정의 필요
	- `소비처 요구사항에 대한 무분별한 데이터 추가 주의`

> 소비처가 필요한 요구사항이 많을 수 있으나 이를 무조건 수용해서는 안된다.
> 이를 수용할 시 결합도가 올라가며, 소비처가 수정될 때 발행처가 함께 영향받을 수 있다.


- 이벤트의 순서가 중요하다!
	- 주문 취소 이후 주문 생성 이벤트가 들어올 수 있다.

## 이벤트 파이프라인

어떤 메시지 브로커를 사용할 것인가? (SNS+SQS , kafka)
- kafka를 선택한 이유
	- 순서 보장
		- 토픽의 파티션을 통해 key별로 순서 보장
		> ex) 파티션을 통해 key별로 순서 보장  
	- 고성능 / 고가용성
		- 파티션 증설을 통해 처리량 증대
		- 메시지 배치 발행
		- 페이지 캐시 등을 이용
		- 브로커를 클러스터로 운용
	- 통합 도구
		- kafka streams 
		- kafka Connect
		등 시스템 개선- 확장할 수 있다.
	- 전담팀 지원





## 카프카를 도입해도 문제가 있을 수 있다

- 카프카 ebs volumn
- 네트워크
- zookeeper 통신이슈

이런 문제들로 이벤트 발행 실패나, 순서가 뒤섞이는 문제가 발생했다.
`도메인의 상태 != 이벤트 발행 결과`


### transactional out box Pattern

이벤트는 outbox에 적재.
message relay가 카프카 클러스터로 전송

이벤트 유실과 순서 보장에 대한 보장이 된다.

### message relay 구현

- 저비용
- 안정성
- 처리량

보통 `debdzuim` 을 많이 사용
(CDC)에서 자주 사용되는 도구임

- 저비용: debezuim은 kafka connect를 통해 등록 / 실행 및 모니터링 제공
- 안정성: Binary log를 통산 순서 보징 및 offset을 활용한 발행 보장
- 처리량: Outbox 테이블 파티셔닝을 통한 처리량 증대

## 이벤트 활용 사례

- 이벤트 유실이 없고 순서가 보장된 이벤트는 이벤트 스트림을 구성
- 이벤트 스트림을  CQRS 적용 (Query모델로 구축)
- 이벤트 스트림으로 데이터 분석 환경 구축

- S3 sink connector 로 S3 + Gue, Athena
  를 통해 데이터 분석 환경
- 이벤트 스트림으로 스트림즈 애플리케이션 구현
