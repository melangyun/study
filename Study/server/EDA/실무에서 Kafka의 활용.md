연관 파일: [[Kafka]]
# 실무 관점에서 생각하는 카프카의 주요한 장점

카프카의 주요한 장점은 카프카가 `다중 컨슈머 기능`을 지원한다는 것이다.
`다중 컨슈머` 기능이란, 여러 개의 컨슈머 그룹이 서로간의 상호 간섭 없이 <u>각각의 오프셋</u>으로 각자 순서에 맞게 메시지를 읽고 처리할 수 있는 것을 말한다.

![다중 컨슈머 기능](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2UfOwDKtP8Aq1jRBiuzJw.png)
> 카프카에서 다중 컨슈머가 가능한 이유는 각각 컨슈머 그룹들은 하나의 토픽내의 메시지를 읽을  때 마다 메시지를 어디까지 읽었는지를 표시하는 오프셋을 개별적으로 관리하고 있기 때문이다.

이러한 방식으로 컨슈머가 메시지를 읽으면 해당 메시지가 소비되어 다른 컨슈머에서는 읽을 수 없게되는 메시지큐(Message Queue)와는 다른 방식이다.

- 오프셋을 컨슈머그룹에서 관리하기 때문에, 여러 컨슈머 그룹이 하나의 토픽에 붙어서 메시지를 읽더라도 각자의 메시지 처리 속도와 서비스 상황에 따라 개별적으로 동작할 수 있게 된다.
- 카프카는 메시지를 디스크에 기록하고 저장한다.
  이는 컨슈머가 메시지 읽기를 시도했다가 실패하더라도 메시지가 유실되지 않는 장점으며, 새로운 컨슈머 그룹이 토픽에 붙어 메시지를 읽을 때 과거에 기록된 메시지를 컨슈머가 읽을 수 있는 장점을 제공한다.

## 활용 예시

- 상품 서비스에서 상품 등록 이벤트를 메시지로 발행했다

### 카프카 이전 

- 해당 메시지에 관심을 가지는 여러 개의 구독 서비스에게 상품 서비스가 push방식으로 메시지를 일일이 전달
- 구독 서비스마다 상품 서비스가 제공하는 API를 폴링
- 상품 서비스의 데이터베이스를 직접 붙어서 확인

### 카프카 활용 

상품 등록 이벤트를 카프카의 토픽에 메시지로 발행하고, 이후에는 해당 메시지에 관심을 가지는 여러 컨슈머 서비스가 해당 메시지를 각자 읽고 본인 목적에 맞는 로직을 실행하면 된다.

> [!tip] 이 구조는 개발과 운영 관점에서 높은 수준의 확장성과 유연성을 제공한다.
> 메시지를 발행하는 쪽에서는 카프카에 메시지를 정확하게 발행하는것에만 집중하고,
> 메시지를 수신하는 쪽에서는 메시지를 읽고 본인 목적에 맞는 로직 처리만 실행하면 되기 때문.
> > 이는 마이크로 서비스가추구하는 독립적인 개발과 배포, 운영을 가능하게 해준다.

또 현재는 구현되지 않은 컨슈머도 추후에 새롭게 구현하여 붙일 수 있고, 그러면서 기존 다른 컨슈머의 동작에는 영향을 주지 않으면서 서비스 로직의 확장을 가져갈 수 있다.

### 예외- 경쟁하는 소비자 패턴(Competing Consumers Pattern)

하나의 메시지가 발행 될 때, 단 하나의 실행만 이루어져야 하는 요구사항이라면, **카프카 보다 메시지 큐를 활용하는 것**이 목적에 더 맞는 구조이다.

![](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q98FiiVpkr3cIimsU2wkQ.png)

경쟁하는 소비자 패턴에서 해당 패턴은 여러 개의 메시지를 빠르게 처리해야 할 때 컨슈머의 수를 늘려 각각의 메시지 소비 속도를 늘린다. 이 상황에선 카프카를 통한 로직 처리보다는 메시지 큐를 활용하는 것이 좋다.


# 카프카를 활용한 서비스 개발 시 주의할 점

카프카가 가진 특징을 명확히 알고 서비스를 구현해야 의도에 맞는 비즈니스 로직 구현과 운영이 가능하다.

## 1. 메시지 순서 보장

도메인 로직 중에는 논리적인 순서 보장이 중요 한 것이 있다.

> [!example] 이커머스에서 주문 -> 바로 취소하는 이벤트 발생시
> - 주문 취소 메시지를 먼저 처리하게 되면 주문 취소과정에는 오류 발생
> - 이후에는 앞선 주문 취소와 상관없이 주문 생성

이러한 문제 상황이 발생하지 않으려면 메시지 발생 순서에 맞게 시스템이 <u>순차적으로 메시지를 읽고 로직을 처리</u> 할 수 있어야 한다. 그리고 이를 위해서는 카프카의 토픽에 메시지를 발행 할 때 <u>메시지의 키 값을 포함하여 메시지를 발행해야 한다.</u>

카프카 파티셔너는 메시지에 키가 없을 때에 라운드 로빈 방식으로 메시지를 파티션에 분배하여 저장하고, 키가 없을 때에는 해당 키 값의 해시를 구한 후 그 값에 맞는 특정한 파티션에 메시지를 저장한다.

그렇기 때문에 메시지의 키 값이 동일하면 항상 같은 파티션에 메시지가 저장되게 된다.

> 개인 생각 (잘못 이해했던 부분)
> - 착각했던 부분: 파티션 키가 같으면 같은 파티션으로 처리되지만, 파티션 key가 파티션을 지칭하는것이 아니다. 키 값의 해시- > 그 값에 맞는 특정한 파티션에 메시지 저장
> - 따라서 단일 파티션만 사용하는 것이 아니라, 동일히 여러 파티션을 쓴다


## 2. 중복 메시지 처리

카프카는 파티션의 각 레코드에 대한 위치를 숫자로 관리하는데 이를 오프셋이라고 한다.
오프셋은 해당 파티션 내에서 레코드의 고유한 식별자 역할을 한다.

1. Consumed Offset(Current Offset)
	컨슈머가 메시지를 어디까지 읽었는가
	해당 오프셋을 통해 컨슈머가 읽어야 할 다음의 메시지 위치를 식별할 수 있다.
	해당 오프셋은 컨슈머가 `poll()` 을 받을 때마다 자동으로 업데이트 된다.
	- 오프셋은 각각의 컨슈머가 관리한다.
2. Committed Offset
	컨슈머가 메시리를 읽고 카프카에게 `여기까지 오프셋을 처리했다`라는 것을 알리는 Offset Commit을 통해 업데이트되는 오프셋.
	컨슈머의 프로세스가 실패하고 다시 시작되면 컨슈머가 다시 메시지를 읽게 될 시작점이 되는 오프셋이다.
	해당 오프셋은 `__consumer_offsets`라고 하는 카프카의 내부 토픽에서 관리한다.


컨슈머가 파티션에서 메시지를 읽어들이는 과정을 `Consumed Offset`과 `Committed Offset`을 연관지어 이야기해보면 다음과 같다.


### 정상적인 동작시의 흐름

[[kafka_consumer_commit.excalidraw]]

1. poll() 메서드가 호출될 때마다 그룹의 컨슈머들이 파티션에서 아직 읽지 않은 메시지를 반환한다.
   이 때 읽어들인 위치만큼 Consumed Offset이 업데이트 된다.
2. 컨슈머에서 읽어들인 메시지를 정상적으로 처리하고, 이후에 Offset Commit을 실행하여 카프카에게 정상처리된 메시지의 최종 위치를 알린다.
3. 이 때의 오프셋이 Committed Offset이다

### 비정상 동작

컨슈머에 장애가 발생하거나, 새로운 컨슈머가 컨슈머 그룹에 추가될 때 `리밸런싱`이 발생하고, 리밸런싱 이후에는 각 컨슈머에게 할당되는 파티션이 바뀔 수도 있게 된다.

- 이 때 각각의 컨슈머는 각 파티션의 `Commited Offset`부터 메시지를 읽어들이게 된다.
  (`Consumed Offset`이 아니라, `Committed Offset`!)
	- [f] 이 구간에서 중복 메시지 이슈가 발생할 수 있다

![dupulicate poling](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEnqOVI49QZfrH89KDBPpQ.png)
> - 2: last committed offset
> - 2까지 작업 이후 11까지 가져가 Consumed Offset이됨
> - 이때 리밸런싱 진행
> - 다시 2이후 메시지를 읽게 되고, `메시지 중복`으로 다시 읽고 처리할 가능성이 생기게 된다.

> [!tip] 카프카를 활용한 비즈니스 구현에서는 `Commited Offset`이후의 메시지 구간에서 중복 메시징 이슈가 발생할 수 있다는 것을 전제루 두고 `컨슈머`가 이러한 상황을 스스로 해결해야 함을 인지하는 것이 중요

### 해결 방안

1. 멱등한(idempotent) 메시지 처리 로직을 구현
	- 동일한 입력 값으로 로직을 반복적으로 실행해도 결과가 달라지지 않고 처음에 처리한 것과 동일한 결과를 가지는 성질
	- 하지만 실제로 멱등성을 유지하면서 로직을 구현하는것은 쉽지 않고, 비즈니스 의미상 멱등성이 불가능한 로직이 있을 수도 있다. 따라서 멱등성을 고려한 중복 메시징 처리는 제한적인 옵션이라고 생각하는것이 좋을것.
2. 중복 메시지를 걸러내는 로직을 구현
	![processed Message table](https://microservices.io/i/IdempotentConsumer/IdempotentConsumer.png)
	아래 로직을 하나의 트랜잭션으로 묶어서 중복된 메시지가 실행되지 않도록 로직을 구현한다.
	- 비즈니스 로직 실행
	- 읽고 처리한 메시지 정보를 insert 하는 것 `-> (unique index)`
	다시 읽게 ehlf Eosms insert 과정이 실패하고 전체 트랜잭션이 롤백되어 동일 메시지가 중복으로 실행되는 경우를 방지할 수 있게된다.


## 3. 트랜잭셔널 메시징

비동기 메시징을 활용한 서비스 구현에서는 비즈니스 로직이 실행되었을 때, 이를 표현하는 이벤트도 온전하게 발행되는 것이 중요하다. 

도메인 로직이 완료된 이후에 이벤트가 발행되지 않는다면, 해당 이벤트를 바라보는 컨슈머는 특정한 로직을 실행할 수 없게 되고, 이로 인해 전체 서비스의 데이터 정합성이 깨지거나, 특정한 로직에서 버그가 발생할 수 있다.

> [!tip] 서비스의 실행과 그 이후의 이벤트 발행을 원자적으로 함께 실행하는 것을 트랜잭셔널 메시지징(Transactional Message)이라고 한다.

트랜잭셔널 메시징을 구현하는 방법은 2가지가 있다.

### 1. 트랜잭셔널 아웃박스 패턴(Transactional Outbox Pattern)

- 비즈니스 로직
- 메시지 발행 (Outbox 테이블에)
하나의 트랜잭션으로 묶어서 실행

원자성을 보장하는 트랜잭션 안에서 비즈니스 로직과 메시지 발행 로직은 항상 함께 성공하거나 실패하게 된다.
이후 outbox를 바라보면서 외부로 메시지를 발행하는 로직을 별도로 구현하면, 비즈니스 로직이 실행되면 반드시 외부로 메시지가 발행되는 것을 보장하는 구현이 완성된다.

![transactional outbox pattern](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXXq4X2bJDWubV-8BzvIGQ.png)
> 이건 더 찾아보니 공부할 내용이 더 많은것같아, 추후 추가 공부하는게 좋을것같다.

### 2. 변경 데이터 캡쳐(Change Data Capture; CDC)

데이터 베이스에서 데이터 변경이 발생 할 때 마다 이를 읽어서 메시지를 발행하거나 로직을 수행하기 위해 사용되는 디자인 패턴

트랜잭셔널 아웃박스 패턴은 비즈니스 로직 개발과 별개로 메시지를 발행하기 위한 추가적인 로직 구현이 필요한데, 메시지 발행 시마다 이러한 구현을 별도로 구현하는것이 다소 부담이 된다.
이 때 CDC를 지원하는 라이브러리 또는 플랫폼을 사용하면, 추가 구현에 대한 부담 없이 비즈니스 로직 실행 이후 메시지 발행을 비교적 쉽게 할 수 있다.

**Debezium**은 CDC를 지원하는 대표적인 플랫폼인데, MySQL의 binlog와 같은 트랜잭션 로그를 활용하여 변경된 데이터를 확인하고, 이후 이를 메시지로 변환하여 타겟으로 설정한 카프카에 발행해준다.

이를 활용하면 트랜잭셔널 아웃박스 패턴보단 메시지 발행을 위한 추가적인 개발 공수를 적게 넣을 수 있지만, Debizium을 학습하고 운영하는 비용이 필요하고, 동작 원리상 테이블의 스키마가 변경될 때 마다 발행되는 메시지의 형태가 바뀔 수 있기 때문에 목표하는 비즈니스 로직에 따라서 트랜잭셔널 아웃박스 패턴과 CDC를 혼용하여 사용하는 것이 필요하다.



## 4. 리밸런싱(Rebalancing) 문제

한 컨슈머로부터 다른 컨슈머로 파티션 소유건이 이전되는 것을 리밸런싱이라고 한다.

리밸런싱이 발생하면 토픽에 연결된 모든 Consumer의 동작이 일시적으로 중지되는데, 이 때문에 카프카를 활용하는 애플리케이션은 리밸런싱으로 인한 서비스 처리 성능 저하를 겪게 된다.

가령, MSA에선 서비스들이 수시로 배포를 진행할 수 잇는데, 그 때마다 기존 컨테이너가 내려가고 신규 컨테이너가 올라가는 과정에서 파티션 소유권이 변경되는 리밸런싱이 수시로 발행하게 되고, 그 때마다 카프카와 관련한 모든 동작이 일시적으로 멈추게 되면(stop the world)해당 서비스의 처리 성능에 대한 고민이 생기게 된다.

> 해당 이슈는 `카프카 2.3` 버전 이후에 `Incremental Cooperative Rebalancing`이라는 디자인이 적용되어 문제가 해결된 상태이다.
> 해당 이슈는 [여기](https://devidea.tistory.com/100)에서 더 자세히 볼 수 있다!

- 한번에 분배가 이루어졌던 기존 방법과는 달리, 여러 단계에 걸쳐서 이루어진다.
- 기존에 할당된 모든 파티션을 해체하고 분배하는 것이 아니라, <u>분배를 필요로 하는 일부 파티션만 각 컨슈머가 자발적으로 해체하고 해당 파티션만 분배가 이루어진다.</u>

> [!tip] 카프카를 활용하여 비즈니스 로직 개발시 주의할점
> 중복 메시징 이슈, 메시지 순서 보장을 위해 고려해야 할 점, 트랜잭셔널 메시징을 지킬 수 있는 개발 방안을 고려하여 카프카를 채택했을 때 얻을 수 있는 장점은 충분히 누리면서 비즈니스 목적에 맞는 개발이 이루어질 수 있도록 해야한다.


---
[실무 관점에서의 Apache Kafka 활용](https://medium.com/@greg.shiny82/%EC%8B%A4%EB%AC%B4-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-apache-kafka-%ED%99%9C%EC%9A%A9-023d468f9182)