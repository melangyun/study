[너무 참고한 링크](https://sihyung92.oopy.io/database/mysql-index)
# 클러스티드 인덱스(Clusted Index)

클러스티드 인덱스는 메모리에 순차적으로 저장되는 인덱스이다. InnoDB에선 PK를 생성하면 PK가 자동으로 클러스티드 인덱스가 된다.
다른 RDBMS는 클러스터링 기능이 선택 사항이지만, Inno DB에서는 클러스터링이 default이기 때문에 사용자가 별도의 명령이나 옵션을 선택하지 않아도(PK를 생성하지 않아도) 내부적으로 사용자에게 보이지 않는 Clusted Index가 생성된다.

클러스터링이란 비슷한 값들을 최대한 모아서 저장하는 방식을 의미한다.

> 스토리지 엔진은 사용자가 요청한 SQL문을 토대로 DB에 저장된 디스크나 메모리에서 필요한 데이터를 가져와 MySQL 엔진으로 전달하는 역할을 수행한다.
> InnoDB, MyISAM, Memory 등이 있습니다. 주로 데이터베이스의 용도가 트랜잭션 발생으로 데이터를 처리하는 [[OLTP(Online Transaction Processing)]] 인 경우가 많으므로 InnoDB를 주로 사용하게 된다.


# Non-clustered Index
논클러스티드 인덱스는 <u>테이블에서 칼럼에 대한 인덱스를 추가하는 것</u>을 말한다.
`CREATE INDEX` 명령어를 통해 인덱스를 만들면 <u>논클러스티드 인덱스 테이블이 추가로 생성</u>된다.
해당 테이블엔 인덱스가 순차적으로 정렬되어 있고, 값으론 PK(클러스티드 인덱스) 값을 담고 있다.
![[논클러스티드인덱스탐색방식.png]]
## 논클러스티드 인덱스 탐색 방식

### a. 수직적 탐색
인덱스 수직적 탐색은 루트 노드에서부터 시작한다.
루트 노드와 브랜치 노드는 ==인덱스 키와 자식 노드 정보로 구성된 페이지(단위)==이다.
수직적 탐색 과정에 찾고자 하는 값보다 <u>크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 노드로 이동</u>합니다.
InnoDB의 경우 Secondary Index를 통해 알아낸 Primary Key로 한번 더 수직적 탐색이 이루어집니다.

### b. 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면 수평적 탐색을 통해 데이터를 찾는다.
인덱스 리프노드끼리는 양방향 Linked List이므로 서로 앞뒤 블록에 대한 주소값을 갖습니다.
필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우(커버링 인덱스)도 있지만, 그렇지 않을 경우 테이블도 액세스해야 한다.

이 때, ROWID가 필요하다.
ROWID는 데이터블럭 주소 + 로우 번호(블록내 순번)로 구성된다.
<u>InnoDB의 경우, Primary Key 가 ROWID 역할을 한다.</u> Primary Key는 Clustered Index, 즉 순차적으로 저장되어 있어 Data record의 물리적인 위치를 알 수 있기 때문이다.
ROWID가 가리키는 데이터 페이지를 버퍼풀에서 먼저 찾아보고 못찾을 때만 디스크에서 블록을 읽습니다. (*읽은 후에는 버퍼풀에 적재*한다.)

>[!tip] [[Sequential access VS Random access]]
> 

## Index Range Scan vs Table Full Sacn
DB 테이블에서 데이터를 찾는 방법은 두가지가 있다.
- 테이블 전체를 이용한다.
- 인덱스를 이용한다.

Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크를 읽어 한 블록에 속한 모든 레코드를 한번에 읽어들인다.
이는 테이블이 클러스티드 인덱스로 정렬되어 있고, 이것은 곧 디스크에서의 파일 순서와 동일하기 때문에 가능하다.

Index Range Scan은 랜덤 액세스와 Single Block I/O로 레코드 하나를 읽기 위해 매번 I/O가 발생한다.
이는 논클러스티드 인덱스 테이블에서 Binary Search로 찾은 결과물(클러스티드 인덱스)을 가져와 다시 디스크에 해당하는 row를 찾아달라고 요청해야하기 때문이다.

> [!tip] 인덱스가 무조껀 유리할까?
>읽을 데이터가 일정량을 넘으면 인덱스보다 Table Full Scan이 유리하다. 즉, 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용하는것이 좋다.
>> 사원 중 이름이 '시형'에 해당하는 데이터를 찾는 D 쿼리는 큰 테이블에서 소량 데이터를 검색해야 하는 경우에 해당할 수 있다.
>  >만약 사원 100만 건 중 60만 건의 이름이 '김' 이라면, B 쿼리를 수행할 때 모든 데이터를 불러들이고 칼럼을 조사해야하는 Table Full Scan이 빠를까? 아니면 60만건의 single I/O를 거치는 Index Range Scan빠를까?


>[!warning] index테이블은 전체 테이블의 10%를 차지한다.

