![저장된 디비 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6txYY%2FbtrRZN1BXuj%2F8iRkKk4RkjnxhKG8pwrUbk%2Fimg.png)

# Redo Log

- [*] 리두 로그는 트랜잭션의 4가지 요소(ACID) 중에서 **D(Durable; 지속성-성공적으로 수행된 트랜잭션은 영원히 반영한다)**에 가장 밀접하게 연관돼있다.

MySQL은 언두 로그와 마찬가지로 데이터 변경 내용을 리두 로그로 기록하고, 이를 통해 MySQL 서버가 비정상적으로 종료됐을 때 일관된 데이터를 갖도록 도와준다.

<u>MySQL 서버가 비정상 종료되면 다음과 같은 문제가 생길 수 있는데</u>, 이때 리두 로그를 활용하면 문제를 해결할 수 있다.

- 커밋됐지만 데이터 파일에 기록되지 않은 데이터
- 롤백됐지만 데이터 파일에 이미 기록된 데이터

커밋됐지만 <u>메모리에만 저장되고 데이터 파일로 기록되지 않은 경우에는 리두 로그의 내용을 복사하기만 하면 된다.</u>
하지만 롤백된 경우라면 리두 로그 만으로 해결할 수 없다. 그래서 <u>변경 전의 데이터를 갖는 언두 로그의 내용을 복사해야 한다</u>. 그럼에도 불구하고 리두 로그 역시 필요한데, 해당 트랜잭션이 커밋됐는지 혹은 롤백됐는지 아니면 실행 중인 상태였는지 확인하기 위해서이다.

참고로 리두 로그도 버퍼(메모리) 공간이 존재한다. 리두 로그의 내용을 반영하려면 랜덤 I/O를 통해 데이터가 저장될 위치를 찾아야 한다. 하지만 매번 디스크에 바로 기록하면 랜덤 I/O 때문에 성능이 떨어지므로, 일정 주기로 버퍼의 내용을 디스크에 동기화하도록 되어 있다.

# Undo Log

> [!info] 언두 로그란 MySQL이 트랜잭션과 격리 수준을 보장하기 위해 백업해둔 변경 전의 데이터이다.
> - 트랜잭션 보장: 트랜잭션이 롤백되면 변경된 데이터를 백업된 이전 버전으로 복구시킨다.
> - 격리 수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 격리 수준에 맞는 데이터를 반환한다.

언두 로그는 상당히 중요하게 사용되지만 <u>그렇다고 항상 사용되지는 않는다.</u>
예를 들어 트랜잭션이 롤백되지 않는다면 사용되지 않을 수 있다. 그래서 상당히 중요한만큼 관리도 많이 필요하다.

언두 로그가 실제로 남는 과정을 살펴보도록 하자. 예를 들어 아래와 같은 UPDATE 쿼리를 실행했다고 하자.
```sql
UPDATE member SET area = "경기" WHERE member_id = 1;
```
그러면 데이터베이스는 우선 커밋 여부와 무관하게 실제 데이터와 버퍼풀(메모리)의 내용을 변경한다. 그리고 언두 영역에는 변경 전의 값을 백업해두다가 커밋되면 현재 상태를 유지하고, 롤백되면 백업 데이터로 복구한다.

이러한 언두 로그의 동작 방식 때문에 아래와 같은 상황들은 좋지 않다.

- 대량의 데이터를 변경 또는 삭제하는 경우
- 트랜잭션을 오래 유지하는 경우

> 예를 들어 1억 건의 레코드가 저장된 100GB의 테이블을 DELETE 한다고 하자. 그러면 테이블에서 모든 레코드가 삭제되지만 동시에 언두 로그로도 복사가 되면서 저장 공간을 100GB 차지하게 되어 문제가 생길 수 있다. MySQL 5.5 부터는 언두 로그를 자동으로 줄여주긴 하지만, <u>그렇다고 해서 트랜잭션 종류 후에 바로 언두 로그가 삭제되지 않으므로 대량의 데이터를 한 번에 처리하는 것은 위험하다.</u>

트랜잭션을 오래 유지하는 것도 위험하다.
트랜잭션이 완료되지 않고 계속 방치된다면 데이터베이스는 해당 트랜잭션이 커밋될지 롤백될지 모르므로 언두 로그를 계속해서 쌓는다. 쌓인 양은 많지 않겠지만, <u>문제는 해당 레코드를 조회하는 쿼리가 실행되면 언두 로그를 뒤져서 변경 전의 레코드를 찾아야 하므로 쿼리 성능이 떨어지게 된다.</u> 그러므로 트랜잭션은 가능한 짧게 유지하는 것이 좋다.

>[! caution] 이 때문이라도 네트워크 요청과 관련된 부분은 가능하다면 반드시 트랜잭션 범위에서 제외시켜야 한다!

# 버퍼풀(Buffer Pool)

버퍼풀은 스토리지 엔진의 핵심 부분으로, 디스크에 저장된 테이블과 인덱스 정보(엄밀히는 페이지)를 캐시해두는 공간이다. 이러한 버퍼 풀은 크게 2가지 역할을 갖는다.

- 캐싱을 통한 읽기 성능 향상
- 쓰기 지연을 통한 쓰기 성능 향상

버퍼풀은 데이터를 임시 저장하기 위한 메모리 공간이므로, 읽기 작업 시에 디스크 읽기 횟수를 줄여 성능을 높일 수 있다. 또한 쓰기 작업을 지연시켜 여러 건의 디스크 쓰기를 한 번에 처리할 수 있는 버퍼 역할도 같이 한다. 쓰기 작업을 매번 따로 수행하면 데이터를 처리할 위치를 찾아야 하는 랜덤 I/O가 발생하지만 버퍼풀을 사용하면 일괄 처리하므로 디스크 I/O를 줄여 성능을 높일 수 있다.

그러므로 버퍼풀은 성능에 상당한 영향을 준다. 그래서 쿼리 요청이 빈번한 서버를 재시작하면 캐싱된 내역이 없어 쿼리 성능이 1/10도 안되게 떨어지곤 한다. 그래서 <u>MySQL은 5.6부터 서버가 셧다운 되기 직전에 버퍼풀을 백업하고, 자동으로 복구할 수 있는 기능을 제공해준다.</u> 이렇게 디스크의 데이터가 버퍼풀에 적재된 상태를 워밍업(warming up)이라고 한다.




---
[Mysql Redo Log 란](https://dus815.tistory.com/entry/Mysql-Redo-Log-%EB%9E%80)
[\[MySQL\] MVCC(다중 버전 동시성 제어)와 데이터베이스가 트랜잭션을 지원하는 방법과 동작 과정](https://mangkyu.tistory.com/288#recentComments)