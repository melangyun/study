# DynamoDB 장단점

## 장점
- 데이터가 key-value 형태로 저장된다. (때문에 빠르다)
- JSON file로 저장되는 개념이라 사용하기 간편하다.
- 수평적 확장성이 좋다.
- 속성에 대한 추가와 변경이 자유롭다.
- 필드 구성이 자유롭다
	> 물론 보조인덱스나, 파티션 키의 경우는 테이블 생성 때만 가능하기 때문에 데이터가 쌓이고 나면 변경하기 어렵다. 하지만 SQL에 비해서는 고려할것이 적다.
- 요청 수에 따라 원활하게 확장되기 때문에 비용 효율적이고 IO 작업을 원활하게 지원한다.
- 완전 관리형 서비스이므로 운영 부담이 발생하지 않는다.
- 성능과 가용성을 위해 데이터를 3곳의 가용 영역에 복제하여 저장하고 있다.


## 단점

- 데이터들 간의 관계(relation)가 없기 때문에 같은 데이터가 여러 컬렉션에 중복되어 들어있을 수 있다. 
	> update가 일어날 경우 모든 테이블에서 작업해주어야 한다.
- 큰 REST API 서비스를 운영할 경우 이를 처리할 수 있는 체계적인 API가 제공되지 않는다.
- ORM 지원 라이브러리도 없고, 있다 하더라도 메이저하지도 않아서 쓰기 힘들 수 있다.
- 여러 쿼리에 대해 일관성, 원자성을 보장하지 않는다. 즉, Transaction 이 없다. 전략으로 사용해야한다.
- 러닝커브

# 사용 사례

여러 글로벌 게임 서비스 업체들이 게임 상태, 플레이어 데이터, 세션 기록 및 리더보드 등 게임 플랫폼의 모든 부분에 DynamoDB를 사용하고있다.
<u>수백만 명의 동시 사용자 및 요청을 지원하는 동시에 밀리초 수준의 액세스 지연 시간을 유지할 수 있다</u>는 점이다.


# Data
DynamoDB는 Document 지향 데이터 모델을 지원해준다.
테이블을 생성하기 위해 기본키를 정의하기만하면 된다. 동적 속성 집합을 사용하여 이러한 테이블에 항목을 추가가 가능하다.
DynamoDB의 Items은 SQL의 row에 해당하고 DynamoDB의 attributes는 SQL의 Column에 해당한다.

> [!info] DynamoDB Data Type
> - Scalar type : 하나의 값만 표현. ;(숫자, 문자열, Binary, Boolean, null)
> - Document type : 트리 형태로 표현 가능한 중첩된 구조
> - Set type : 집합 (포함된 항목들은 고유해야 한다)

> [!tip] scalar type
> - 숫자: 최대 8자리 까지 지원
> - String:  UTF-8 인코딩을 사용. 문자열 길이는 0을 **초과**해야 한다.
> - Binary: 실행 파일이나 압축 파일, 이미지와 같은 모든 이진 데이터를 저장하기 위한 타입.
>   비교시에는 각 바이트를 `unsigned char` 로 간주한 다음 대소를 비교한다.
>   크기는 문자열과 마찬가지로 0 초과, 항목 내 다른 속성의 크기에 따라 최대 400KB 제약을 갖는다.바이너리를 기본 키로 사용하는 경우에도 문자열과 같이 파티션 키일 경우 2KB, 정렬 키일 경우 1KB 제약을 갖습니다.애플리케이션 상에서 바이너리 데이터를 DynamoDB로 보내기 전에는 Base64로 인코딩해야 합니다.
>   - Boolean: `true` or `false`
>   - Null: `unknown` or `undefined`

>[!tip] Document type
>문서 타입에는 List와 Map이 있다.
>이 둘은 서로 중첩 가능하며, 32단계까지 중첩 가능.
>리스트와 맵 안의 값의 갯수는 제한이 없지만 400KB의 항목 크기 제한은 있다.
>속성 값에 빈 문자열이나 공집합은 허용되지 않지만, 빈 리스트나 빈 맵은 허용된다.

> [!tip] set typs
> 숫자 집합, 문자열 집합, 이진수 집합을 지원한다.
> 집합 내 모든 원소 타입은 동일해야 하며, 집합 내 값의 수에는 제한이 없지만 400KB를 유념해야 한다.
> 집합 내 원소들은 유일해야 한다.

# Key

## Partition Key

하나의 속성으로 구성되는 기본키. 해시키 라고도 불린다.
> DynamoDB가 내부적으로 Item을 저장할 파티션을 결정할 때
> 해시 함수에 파티션 키를 넣은 결과를 사용하기 때문

- [f] 파티션 키 외 다른 키가 없는 테이블에서는 어떤 Item도 동일한 파티션 키를 가질 수 없다.

## Partition Key & Sort Key

복합 키는 두개의 속성으로 구성된다.
1. 파티션 키
2. 정렬키
파티션 키가 같은 항목들은 <u>정렬 키값을 기준으로 정렬</u>되어 저장된다.
> 파티션 키와 정렬 키로 구성되어 있는 테이블에서는 두 개의 항목이 동일한 파티션 키 값을 가질 수 있지만, 두 아이템 간 정렬 키 값은 달라야 한다.
> 정렬 키는 **범위키** 로도 불린다.

## Secondary Index

보조 인덱스는 기본 키에 대한 쿼리 뿐 아니라, *대체 키를 사용하여 테이블의 데이터에 대한 쿼리를 할 수 있는 방법을 제공한다.*
> 파티션 키 외의 내용으로 쿼리해야 하는 경우가 생각보다 많다.
> sql 에서는 foriegn key와 join tabl로 해결했지만, 여기서는 인덱스라고 이야기하는 보조키로 해결한다.

DynamoDB에서 제공하는 인덱스는 두 가지 이다.
- GSI: 파티션 키 및 정렬 키가 테이블의 파티션 키 및 정렬 키와 다를 수 있다.
- LSI: 테이블과 파티션 키는 동일하지만 정렬 키가 다르다.

테이블당 각각 최대 <u>5개의 보조 인덱스를 정의할 수 있다</u>.

| 특성                     |                                      글로벌 보조 인덱스<br>GSI                                       |                                                       로컬 보조 인덱스<br> LSI                                                        |
| ------------------------ |:----------------------------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------:|
| 키 생성 기준             |             단순 기본 키(파티션 키)이거나 복합 기본 키(파티션 키 및 정렬 키)일 수 있다.              |                                     기본 키는 반드시 복합 기본 키(파티션 키 및 정렬 키)여야 한다.                                     |
| 타입                     | 인덱스 파티션 키 및 정렬 키(있을 경우)는 문자열, 숫자 또는 이진수 형식의 기본 테이블 속성일 수 있다. | 인덱스의 파티션 키는 기본 테이블의 파티션 키와 동일한 속성이다. 정렬 키는 문자열, 숫자 또는 이진수 형식의 기본 테이블 속성일 수 있다. |
| 파티션 키                |                                            크기 제한 없음                                            |                                                          10GB 이하.                                                          |
| 온라인 인덱스 작업       |             1. 테이블을 생성할 때 동시에 생성 가능<br/>2.기존 테이블에 추가, 삭제 가능.              |                                   테이블을 생성할 때만 생성 가능.<br/>그 후에는 추가, 삭제 할 수 없다.                                    |
| 프로비저닝된 처리량 소비 |                   쿼리 및 스캔은 기본 테이블이 아닌 인덱스의 용량 단위를 소비한다.                   |                 기본 테이블의 읽기 용량 단위를 소비한다. 테이블에 쓸 때 해당 local secondary indexes도 업데이트 된다.                 |


### LSI (LOCAL SECONDARY INDEX); 로컬 보조 인덱스

![LSI](https://velog.velcdn.com/images%2Fhanseul%2Fpost%2Fa72a50d4-91eb-4bf5-bdc0-649965a88859%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-31%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.34.00.png)
> - FornumName => 파티션 키
> - Subject => 정렬 키
> - LastPostDateTime, Replies => attribute

파티션 키 + 정렬키
동일한 파티션 키 내에서 정보를 분리하고 싶을 때 사용
로컬 인덱스의 경우, 테이블을 만들 때 미리 설정해 두어야 한다. 한번 설정한 후에는 삭제, 추가, 수정이 불가능하다.

### GSI(GLOBAL SECONDARY INDEX; 글로벌 보조 인덱스

기본키와 정렬키와는 별개로 <u>특정 키를 인덱스 키로 활용할 수 있는 개념</u>.
기존에 있던 필드를 글로벌 보조 인덱스를 만들면, 해당 인덱스를 기준으로 가상의 새로운 테이블이 형성된다.

![GSI](https://velog.velcdn.com/images%2Fhanseul%2Fpost%2F2454ccc3-befa-40df-96e2-90f75dc0cfe2%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-31%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.21.14.png)
> - UesrId  => 파티션키
> - GameTitle => 정렬키

이 상황에 각 게임의 최고점수를 표기하는 순위표를 만들기 위해서는 GateTime만을 토대로 GaneScores에 데이터 검색을 해야 할 경우 Scan작업을 해야 하기 때문에 효율이 떨어진다.
반면 UserId로 쿼리하면 특정 게임의 최고기록 점수자를 찾을 수 없다. (경기별로 볼 수 없기 때문에)

- [p] TopScore를 GSI 인덱스로 만들고, 해당 인덱스를 기준으로 쿼리

> [!warning] 보조 인덱스로 쿼리는 할 수 있지만, 보조인덱스로 update는 불가능하다.
> 보조 인덱스로 쿼리 후 파티션키를 찾아 업데이트를 해야 한다.
> 


> [!check] 로컬 보조 인덱스의 활용
> 로컬 인덱스를 사용하는 경우는 `hot key` 이슈를 막기 위함이다.
> >특정 파티션 키만 유독 많이 사용되어 용량이 몰리는것
> 





---
[DynamoDB 장단점과 DynamoDB를 시작 전에 알면 좋은 11가지](https://sujl95.tistory.com/84)
[ DynamoDB 개념정리](https://velog.io/@krlrhkstk/DynamoDB-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC)
[AWS DynamoDB 사용기_보조 인덱스 사용 위주로](https://velog.io/@hanseul/AWS-DynamoDB-%EC%82%AC%EC%9A%A9%EA%B8%B0)