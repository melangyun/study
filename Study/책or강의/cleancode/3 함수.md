어떤 프로그램이든 가장 기본적인 단위가 함수다.

# 작게 만들어라.

함수를 만드는 첫째 규칙은 '작게'다. 
`if / else` , `while` 등에 들어가는 블록은 한 줄이어야 한다. 대게 거기서 함수를 호출하고, 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록안에서 호출하는 함수 이름을 적절하 짓는다면 코드를 이해하기도 쉬워진다.
> 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.

# 한가지만 해라!

함수는 한가지를 해야 한다. 그 한가지를 잘해야 하며, 한가지만을 해야한다.
> 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서다.


# 함수 당 추상화 수준은 하나로

함수가 확실히 `한가지` 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- `getHTML()`은 추상화 수준이 아주 높다.
- 반면 `String pagePathName = PathParser.render(pathPath);` 는 중간수준
- `append("\n")`와 같은 코드는 추상화 수준이 아주 낮다.
한 함수 내에서 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지, 세부사항인지 구부하기 어려워진다.

근본 개념과 세부사항을 뒤섞기 시작하면, 깨진 창문처럼 사람들이 세부사항을 점점 더 추가한다.


## 위에서 아래로 코드 읽기: 내려가기 규칙

코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

# Switch문
switch문은 작게 만들기 어렵다.
> case 분기가 단 두개인 switch문도 너무 길다(저자 취향상)
> 또, `한 가지`작업만 하는 switch문도 만들기 어렵다. 본질적으로 switch문은 N가지를 처리한다.  

하지만 다형성을 이용하여 switch문을 저차원 클래스에 숨기고 절대 반복하지 않는 방법은 있다.

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType{
  switch(e.type){
    case COMMISSIONED:
      return calculateCommissionedPay(e);
    case HOURLY:
      return calculateHourlyPay(e);
    case SLARIED:
      return calculateSalariedPay(e);
    default:
      throw new InvalidEmployeeType(e.type);
  }
}
```

위 함수는 몇가지 문제가 있다.
1. 함수가 길다. 
	- 새 직원 유형을 추가하면 더 길어진다.
2. 한가지 작업만 수행하지 않는다.
3. SRP를 위반한다.(코드를 변경할 이유가 여럿이기 때문에)
4. OCP를 위반한다. (새 직원 유형을 추가할 때마다 코드를 변경하기 때문에)

가장 심각한 문제는 위 함수와 구조가 동일한 함수가 무한정 존재한다. 그리고 모두 똑같이 유해한 구조이다.

```java
// Employee and Factory
public abstract class Employee {
  public abstract boolean isPayday();
  public abstract Money calculatePay();
  public abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
    switch(r.type){
      case COMMISSIONED:
        return new CommissionedEmployee(r);
      case HOURLY:
        return calculateHourlyPay(e);
          case SLARIED:
      return calculateSalariedPay(e);
    default:
      throw new InvalidEmployeeType(e.type);
    }
  }
}
```

이런식으로 상속 관계를 숨긴 후 `절대로` 다른 코드에서 노출하지 않는다.
# 서술적인 이름을 사용하라

코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.
한가지 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 이미 절반은 성공했다.

서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다. 좋은 이름을 고른 후 코드를 더 좋게 재구성하는 사례도 없지 않다.

> 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
> 문체가 비슷하면 이야기를 순차적으로 풀어가기도 쉬워진다.

# 함수 인수

함수에서 이상적인 인수 개수는 0개 > 1개 > 2개
3개는 가능한 피하는 편이 좋으며, 4개 이상은 특별한 이유가 필요하며, 특별한 이유가 있어도 사용하면 안된다.

## 많이 쓰는 단항 형식

함수에 인수를 1개 넘기는 이유
- 인수에게 질문을 던지는 경우
- 인수를 뭔가로 변환해 결과를 반환하는 경우

