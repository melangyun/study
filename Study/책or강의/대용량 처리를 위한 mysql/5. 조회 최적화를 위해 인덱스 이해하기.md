# 1. 데이터베이스 성능 핵심

>[!tip] 디스크 랜덤 IO접근을 최소화 하는것이 DB성능의 핵심이다.


![[데이터를 저장하기 위한 공간.png]]

데이터베이스도 결국 서버 컴퓨터이다. 다음 구조중 데이터를 담아 둘 수 있는곳은 **메모리**와 **디스크**이다.


|        | 메모리                      | 디스크        |
| ------ | --------------------------- | ------------- |
| 속도   | 빠름                        | 느림          |
| 영속성 | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
| 가격   | 비쌈                        | 저렴함        |


데이터베이스의 데이터는 결국 디스크에 저장된다. 하지만 디스크는 메모리에 비해서 훨씬 느리다.
- [*] **결국 데이터베이스 성능의 핵심은 I/O접근을 최소화 하는것이다.**
- [?] 하지만 디스크 접근은 어떻게 줄일 수 있을까?
- [p] 메모리에 올라온 데이터로 최대한 요청을 처리한다.
	- 메모리 캐시 히트율을 높인다
	- 쓰기도 일단 메모리에 쓴다
	- 메모리 데이터 유실에 대비해 [[WAL (Write-Ahead Log)]] 를 사용한다.

# 2. 인덱스의 핵심
자세한 내용은 : [[Index]]

>[!tip] 인덱스는 탐색(검색) 범위를 최소화 하는것!
>index설정히 cardinality라고 하는 데이터의 식별 정도가 높은것을 하는것이 좋음
(ex: 남자, 여자 둘 뿐이면 탐색 정도가 두개밖에 되지 않아 식별도가 낮음)


## 쿼리 프로파일
```SQL
# 쿼리 프로파일링 설정
SET profiling=1;

# 프로파일 쿼리 갯수 확인
SHOW VARIABLES LIKE '%profiling_history_size'

# 프로파일 쿼리 갯수 설정
SET profiling_history_size = 150;
SHOW PROFILES;

# 프로파일 쿼리 목록 확인
SHOW PROFILE FOR QUERY

# 213번 쿼리 프로파일 확인
SHOW PROFILE FOR QUERY 213;

# 쿼리 프로파일 설정 해체
SET PROFILING = 0;

# 쿼리 로그 설정
SET GLOBAL general_log=on;

# 확인
SHOW variables like 'general%';
```

# 3. 인덱스 자료구조
^533e28

인덱스의 핵심은 탐색(검색) 범위를 최소화 하는 것이다.
검색이 빠른 구조들은 어떤 것이 있을까?

- HashMap
	- 단건 검색속도 `O(1)`
	- 그러나 범위 탐색은 `O(N)`
	- 전방 일치 탐색 불가 (ex: like 'AB%')
	- [!] 하지만 메모리 디비에는 해시맵이 사용되기도 한다.
- List
	- 정렬되지 않은 리스트의 탐색은 `O(N)`
	- 정렬된 리스트의 탐색은 `O(logN)`
	- 정렬되지 않은 리스트의 정렬 시간 복잡도는 `O(N) ~ O(N*logN)`
	- 삽입/삭제 비용이 매우 높음
- Binary Search Tree
	- <u>트리 높이</u>에 따라 시간 복잡도가 결정됨
	- 트리의 높이를 최소화하는 것이 중요
	- 한쪽으로 노드가 치우치지 않도록 <u>균형을 잡아주는 트리</u> 사용
		- Red-Black Tree, B+ Tree

## 대부분의 rdbms는 B+Tree를 사용한다.

- 삽입 / 삭제시 항상 균형을 이룬다.
- 하나의 노드가 여러 개의 자식 노드를 가질 수 있다.
- <u>리프노드에만 데이터가 존재</u>하며, 부모 노드는 Key로서 역할한다.
	- 연속적인 데이터 접근시 유리하다 
	> (리프끼리 연속적으로 존재하여)


> [!warning] 데이터의 변경시 B+Tree의 리벨런싱 비용 상승
>Mysql은 모든 인덱스 테이블이 PK를 갖고 있다.
>PK의 사이즈가 커지게 되면, 하나의 노드가 가질 수 있는 데이터의 갯수가 적어진다.
>삽입/ 삭제/ 업데이트시 B+Tree의 리밸런싱 비용이 커질 수 있다.
>---
>그렇다면 index를 설정하면, 조회의 성능은 좋아질 수 있지만, 갱신의 성능은 낮아지므로,
>이 둘의 균형을 잘 잡는것이 중요하다.

# 4. 클러스터 인덱스
[[Clusted Index]]
1. 클러스터 인덱스는 데이터 위치를 결정시키는 키값이다.
2. MySQL PK는 클러스터 인덱스다
3. MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.

클러스터키는 정렬을 이루고, 정렬에 따라서 데이터 주소가 결정된다.
따라서 클러스터 키 삽입/ 갱신시 성능이슈가 발생하게된다.

cf) [[PK Auto Increment vs uuid]]

- pk의 사이즈가 인덱스의 사이즈를 결정한다.
	> (세컨더리 인덱스만으로는 데이터를 찾아갈 수 없기때문에, 항상 pk를 검색해야 한다.)

> [!tip] pk를 활용한 검색이 가장 빠르다
> 특히 범위검색의 경우.
> - [p] 세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리하다.

# 6. 인덱스를 다룰 때 주의해야 할 점


## 1. 인덱스 필드 가공
```SQL
SELECT * FROM Member WHERE age * 10 = 1;
```

위 예시에서, age column에 index 가 있다고 하더라도, column값을 변형시키고 있기 때문에 의미가 없다.
> 자료형을 변경시킬때도 마찬가지이다.

## 2. 복합 인덱스
| 과일   | 원산지      | PK  |
| ------ | ----------- | --- |
| Apple  | USA         | 1   |
| Banana | China       | 5   |
| Banana | Korea       | 4   |
| Mango  | Philippines | 3   |

위와같은 복합인덱스의 경우, 과일 순으로 먼저 정렬이 된 후, 그 안에서 원산지 순으로 정렬이 된다.
따라서, Where문의 조건으로 원산지가 들어올 경우, index를 탈수 없다.
> (원산지는 정렬이 되어있지 않기 때문에!)

>[!tip] 따라서 복합 인덱스의 경우 선두 인덱스를 무엇으로 설정할것인지가 중요하다!

>[!info] 하나의 쿼리에는 하나의 인덱스만 탄다.
>여러 인덱스를 동시에 탐색하지 않는다.
>> but index merge hint를 이용하면 가능하다.
>
>따라서 Where, order by, Group by 혼합해서 사용할 때 인덱스를 잘 고려해야 한다.

> [!danger] 주의사항
> -  의도대로 인덱스가 활용되지 않을수도 있다
> - 인덱스도 비용이다. 쓰기를 희생하고, 조회를 얻는 것이다.
> - 꼭 인덱스로만 해결할 수 있는 문제인지 고민해보는것이 중요하다.
