> [!tip] Mysql을 학습해야 하는 이유
> 아직 RDB가 가장 범용적으로 사용되고 있다.
> 여러 DB를 알아야하지만, 여러 종류의 데이터 베이스들은 서로의 문제를 보완하고 발전한 상호보완적인 관계이기 때문에, 한가지를 깊게 학습하고 나면 다른 종류의 DB도 쉽게 학습할 수 있게 된다.

## 데이터베이스는 파일을 관리하는 서버이다.
![[mysql 아키텍처.png]]
데이터베이스는 파일을 관리하는 서버이다. DBMS관점에서는 웹서버 어플리케이션이 클라이언트이다.

### mysql 엔진
- 쿼리파서
	- SQL을 파싱하여 Syntax Tree를 만듬
	- 이 과정에서 문법 오류 검사가 이루어짐
- 전처리기
	- 쿼리파서에서 만든 Tree를 바탕으로 전처리 시작
	- 테이블이나 컬럼 존재여부, 접근권한 등 Semantic 오류 검사
- [!] 쿼리파서, 전처리기는 컴파일 과정과 매우 유사하다
      하지만, SQL은 프로그래밍 언어처럼 컴파일 타임때 검증 할 수 없어 매번 구문 평가를 진행한다.

- 옵티마이저
	- 쿼리를 처리하기 위한 여러 방법들을 만들고, 각 방법들의 비용정보와 테이블의 통계정보를 이용해 비용 산정
	- 테이블 순서, 불필요한 조건 제거, 통계정보를 바탕으로 전략을 결정(**실행 계획 수립**)
	- 옵티마이저가 어떤 전략을 결정하느냐에 따라 성능이 많이 달라진다.
	- 가끔 성능이 나쁜 판단을 해 개발자가 힌트를사용해 도움을 줄 수 있다.
- 쿼리실행기
	- 옵티마이저가 결정한 계획대로 스토리지 엔진에 요청-읽어오는 역할을 함
	> 이 때 HandlerAPI를 사용
	> 스토리지 엔진에 요청하는것을 핸들러 요청이라고 함.
	> 이 핸들러 API를 만족하는 스토리지 엔진을 만들기만 하면, 직접 구현, 추가해서 사용할 수 있다.

### 쿼리 캐시
Mysql 5버전까지는 쿼리 캐시 기능이 존재. *8.0 이후부터 쿼리캐시가 폐기되었다.*

- **소프트 파싱**: SQL실행 계획을 캐시에서 찾아 옵티마이저 과정을 생략하고 실행 단계로 넘어감
- **하드 파싱**: SQL 실행계획을 캐시에서 찾지 못해 옵티마이저 과정을 거치고 나서 실행 단계로 넘어감

MySQL에는 소프트 파싱이 없다.
하지만 5버전까지는 쿼리 캐시(SQL에 해당하는 데이터를 저장하는것)가 있었다.
쿼리캐시는 데이터를 캐시하기때문에, 테이블의 데이터가 변경되면 캐시의 데이터도 함께 갱신시켜줘야 한다.

Oracle에는 소프트 파싱이 있다.
실행계획까지만 캐싱하지만, 모든 SQL과 맵핑해 데이터까지 캐싱하지는 않는다.
(힌트나 설정으로 가능하기는 함)

Mysql의 쿼리 캐시, Oracle의 소프트 파싱 모두 성능 최적화를 위해 캐시를 도입한 사례이다.
> Mysql의 쿼리캐시는 데이터가 변경되면 모두 삭제해야 하므로, 동시 처리 성능 저하를 유발하고 많은 버그의 원인이 되어 폐기되었다.

**그러나 캐시의 범위가 다르다.**
캐시를 도입할 때는 항상 만료정책을 고려해야 하며, 쿼리캐시는 소프트 파싱에 비해 조회성능은 더 높지만, 캐시 데이터 관리에 더 높은 비용이 들어간다.

> 모든 기술은 트레이드 오프다


### 스토리지 엔진
- 디스크에서 데이터를 가져오거나 저장하는 역할
- MySQL 스토리지 엔진은 플러그인 형태로 Handler API만 맞춘다면 직접 구현해서 사용할 수 있다.
- InnoDB, Mylsam 등 여러개의 스토리지 엔진이 존재하며, 8.0대 부터는 InnoDB엔진을 디폴트로 사용한다.

#### InnoDB
- [[Clusted Index]]
- [[Undo Log, Redo Log, Buffer Pool]]