# 8.1 애그리거트와 트랜젝션

- 운영자가 주문 상태를 변경하려고 하고 이와 동시에 고객이 배송지를 변경하려고 한다
> 두 사용자가 동시에 변경할 때 트랜젝션 문제가 발생하게 된다.

다음 두가지 중 하나로 선택해야 한다.
1. 운영자가 배송지 정보를 조회하고, 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.
2. 운영자가 배송자 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 재 조회 후 수정하도록 한다.

> [!check] 이 두가지는 애그리거트 자체의 트랜젝션과 관련있다.
> 대표적인 트랜젝션 처리 방식에는 두가지가 있다.
> 1. 선점 잠금(Pessimistic lock)
> 2. 비선점 잠금(Optimistic lock)

# 8.2 선점 잠금 (Perssimistic lock)

선점 잠금은 먼저 애그리거트를 구한 스레드가, 애그리거트 사용이 끝날 때 까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.

> [!check] 선점잠금은 보통  DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.
> DBMS가 `for update`같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금잠치를 제공한다.

> [!cite] typeorm에도 lock 설정을 할 수 있다.
> ```ts
> queryRunner.manager()
> 	.getRepository()
> 	.useTransaction(true)
> 	.setLock("perssimistic-write")
> 	.
> 	.
>```

>[!caution] 선점 잠금 기능을 사용할 때는 자금 순서에 따른 교착상태가 발생하지 않도록 주의해야 한다.
>선점 잠그에 따른 교착상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높다.
>> 이런 문제에 빠지지 않도록 하려면 최대 대기시간을 지정해야 한다.
>만일 교착상태가 발생한다면 어떻게 할까? >> [[DB에서 교착상태를 확인- 처리하기 위한 방식]] (보편적인 방식 은 timeout 및 retry)


# 8.3 비선점 잠금(Optimistic lock)

비선점 잠금은 동시에 접근하는 것을 막는 대신, 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.

비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.

```SQL
UPDATE aggtable SET version = version + 1, colx = ?, coly = ?
WHERE aggid = ? and version = 현재버전
```
>[!check] 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다.
>수정에 성공시 버전 값 1 증가

---
참조하면 좋을 DB 특성: [[동시성 제어]]

# 8.4 오프라인 선점 잠금

