만약 쇼핑몰에서 구매를 취고하면 환불을 처리해아한다.
보통 결제 시스템은 외부에 존재하는데, 이로인해 두 가지 문제가 발생할 수 있다.
1. 외부 시스템이 정상이 아닐경우 트랜잭션을 어떻게 처리해야할까? (롤백/ 커밋 ?)
2. 성능
	외부 시스템에 응답이 길어지는 만큼 대기시간도 함께 길어진다.
	외부 서비스 성능에 직접적인 영향을 받게 된다.

> [!question] 이러한 문제는 주문과 결제 바운디드 컨텍스트간의 강결합 때문이다.
> 이러한 강 결합을 없앨 수 있는 방법은 바로 이벤트를 사용하는 것이다.
> 즉히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.

> [!tip] 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행되어야 한다.
> 이벤트 처리 실패와, 트랜잭션 실패를 함께 고려해야한다.
> 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이 좋다.


# 10.2 이벤트 개요

## 10.2.1 이벤트 관련 구성요소

도메인 모델에 이벤트를 도입하려면 네개의 구성요소 `이벤트` , `이벤트 생성 주체`, `이벤트 디스패처(퍼블리셔)`, `이벤트 헨들러(구독자)`를 구현해야 한다.

![이벤트 관련 구성요소](https://user-images.githubusercontent.com/42582516/160224240-ca76a9a2-321c-456b-a27b-d745d5b36b0e.png)
- 도메인 모델에서 이벤트 생성 주체는 엔티티, 벨류, 도메인 서비스와 같은 <u>도메인 객체</u>이다.
	이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.
- 이벤트 핸들러는 이벤트 생성 주체가 발생한 이벤트에 반응한다.
	애벤트 핸들러는 이벤트를 받아, 데이터를 이용해 원하는 기능을 실행한다.
- 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 **이벤트 디스패처**이다.
	이벤트를 전달받은 디스패처는 <u>해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파</u>한다

## 10.2.2 이벤트의 구성

- 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
- 이벤트 발생 시간
- 추가 데이터: 주문정보, 신규 배송지 정보 등 이벤트와 관련된 정보

## 10.2.3 이벤트 용도

1. 트리거
	도메인 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
2. 서로 다른 시스템 간의 동기화

## 10.2.4 이벤트의 장점

이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

# 10.5 동기 이벤트 처리 문제

이벤트를 비동기로 구현할 수 있는 방법은 다양하다.

- 로컬 핸들러를 비동기로 실행하기
	스프링에서 `@Async` 애너테이션을 사용하면 손쉽게 이벤트 핸들러를 실행할 수 있다.
- 메시지 큐를 사용하기
	KafKa, 래빗 MQ같은 메시징 시스템 사용하기
	- 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.
	  도메인 기능을 실행한 결과를 DB에 반영하고 이 과정에서 발생한 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 실행하려면 글로벌 트랜잭션이 필요하다.
- 이벤트 저장소와 이벤트 포워더 사용하기
	이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는것
	- 이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장
	- 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행
	이 방식은 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다.
	- [f] 이벤트를 외부에 제공하는 API를 활용하는 방법도 있다
- 이벤트 저장소와 이벤트 제공 API 사용하기

# 10.6 이벤트 적용시 추가 고려 사항

1. Event 소스를 EventEntry에 추가할 지
	없다면 `Order가 발생시킨 이벤트만 조회하기` 처럼 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현 할 수 없다.
2. 포워더에서 전송 실패를 얼마나 허용할 것인가
	계속해서 실패하게 된다면, 그 이벤트 때문에 나머지 이벤트를 전송 할 수 없게된다.
	따라서 재전송 횟수 제한을 두어야 한다.
3. 이벤트 손실
	이벤트 저장소를 사용하는 방식은, 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 알 수 있다.
	> 반면, 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.
4. 이벤트 순서
	외부 시스템에 발생 순서대로 전달해야 할 경우 이벤트 저장소를 사용하는 것이 좋다.
	메시징 시스템은 발생 순서와 전달 순서가 다를 수 있다.
5. 이벤트 재처리
	동일한 이벤트를 다시 처리해야 할 때 이벤트를 어떻게 할지 결정해야 한다.
	가장 쉬운 방법은, 마지막으로 처리한 이벤트의 순번을 기억해 두었다가, 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것이다.
	이 외에 이벤트를 멱등성으로 처리하는 방법도 있다.

> [!NOTE] 멱등성
> 연산을 여러번 해도 결과가 달라지지 않는 성질
> > 이벤트 처리도 동일 이벤트를 한 번 처리하나, 여러번 적용하나, 시스템이 같은 상태가 되어야 한다.
> > 주소를 변경하는 핸들러는, 그 이벤트를 한 번 처리하나, 여러번 처리하나 동일하여야 한다.

