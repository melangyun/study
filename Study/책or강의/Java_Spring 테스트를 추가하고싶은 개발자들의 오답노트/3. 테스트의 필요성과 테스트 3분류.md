레거시 코드는 무엇인가.
- 오래된코드? -> 그러면 얼마나 오래되야 레거시일까?
> 마이클 팰더스가 이야기하는 레거시 코드는 `테스트가 없는 코드`
> 더 엄밀히 이야기하면 시간과는 관계가 없다.

**테스트는 왜 필요한가? Regression**

회귀버그, 수정이 무서워진다.
- [?] 하지만 구성원들 개인이 조금만 더 신경을 쓰면 되는 문제가 아닐까?
	- 아니다. 생각보다 큰 문제이다.
	- `구글 엔지니어들은 이렇게 일한다.` > 구글에서도 불안에 떨며 릴리즈하고, 생산성이 낮아졌다.
	- 개인의 문제가 아니다.
## 좋은 아키텍처를 유도한다.

- [?] 좋은 아키텍처는 무엇인가?

SOLID와 테스트는 생각보다 굉장히 긴밀한 상관관계를 갖는다. 완전히 정비례 한다고 볼수는 없지만, 서로가 서로에게 상호 보안적이다.

>[!info] SOLID
>- S: 단일 책임의 원칙
>	테스트가 너무 많아져서 이게 무슨 목적의 클래스인지 눈에 안들어오는 지점이 생김. 이 때가 클래스를 분할해야 하는 시점.
>	  그러면서 책임이 자연스럽게 분배됨
>- O: 개방 폐쇄 원칙(OCP)
>	테스트 컴포넌트와 프러덕션 컴포넌트를 나눠 작업하게 되고, 필요에 따라 이 컴포넌트를 자유자재로 탈부착이 가능하게 개발하게 됨
>- L: 리스코프 치환 원칙
>	이상적으로 테스트는 모든 케이스에 대해 커버하고 있으므로,
>	서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해줌
>- I: 인터페이스 분리 원칙
>	테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경.
>	불필요한 의존성을 실제로 확인할 수 있는 샌드박스
>- D: 의존성 역전 원칙
>	가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어있어야 하는 경우가 생김

- [f] 테스트를 넣으면서 이런 것도 함께 챙겨줘야 한다는 의미이지, 테스트를 작성한다고 SOLID가 되는것은 아니다.

> [!check] 테스트의 가치
단순히 회귀 버그 방지를 위한 테스트를 작성하게 되면 가치가 덜 한 편이지만, 회귀 버그 방지와 설계를 위한 도구로 보면 가치가 높다.

# 2. 테스트의 3분류

- E2E (API테스트)
- Integration (통합 테스트)
- Unit(단위 테스트)

- [?] 통합테스트는 무엇인가. API를 여러개 호출하는 테스트는 통합테스트인가?
	만약 그렇다면 통합 테스트는 왜 API테스트 하위에 있나?

사람마다 정의하는게 다르다.

> [!info] 구글의 테스트 3분류
> 대형 / 중형 /소형 테스트
> - 소형 테스트: 단일 서버/ 단일 프로세스 / 단일 스레드에서 돌아가는 테스트
> 	- Disk IO (X)
> 	- Blocking call (X) -> 따라서 Thread sleep이 테스트에 있다면 소형 테스트가 아님
> 	**빠른 테스트 속도와, 결정적인 결과를 위함**
> - 중형 테스트
> 	  - 멀티 프로세스와 멀티스레드를 사용할 수 있다. (Test DB 사용 가능)
> 	  - 모든 테스트가 h2를 사용한다면, 모든 테스트가 중형테스트인것. 좋은 방향성이 아니다.
> - 대형 테스트
> 	- 멀티 테스트가 사용이 가능해진다. (e2e) 서비스 가능

**프로젝트에 아직 테스트가 없다면, 소형 테스트를 늘릴 수 있는 환경을 만들고, 소형 테스트를 만들어야 한다.**

