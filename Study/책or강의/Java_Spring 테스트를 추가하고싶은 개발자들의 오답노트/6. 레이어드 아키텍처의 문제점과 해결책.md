레이어드 아키텍처 - 유사한 기능들을 같은 계층으로 묶어 관리하는 방식의 아키텍처 구조
![레이어드 아키텍처](https://blog.doctornow.co.kr/assets/images/Blank_Diagram-5294af6541787b0b4723bcba267ecc3a.png)
의존성 역전이나 추상화가 없다.
- 장점: 쉽다
- 단점

## DB위주의 설계를 하게된다.

`레이어드 아키텍처를 사용하면 데이터베이스 주도의 설계가 나온다.`
하지만, DB위주의 설계가 필요한것이 아니라, <u>UseCase를 먼저 파악하는것</u>이 중요하다.

>주문 시스템은 주문하기, 주문 내역 확인, 주문 취소가 가능해야 한다.

이런 걸 파악하는게 먼저고, 이를 처리하기 위한 도메인과 도메인의 관계를 생각하는게 먼저여야 한다.`

## 동시작업

어떤 기능을 개발해야 한다고 했을 때  영속성 객체와 Repository가 나와야 Serivce개발이 가능하고 Service가 나와야 Controller개발이 가능해진다. 그래서 특정 기능 개발은 한 명만 수행이 가능해진다.

> 계층형 아키텍처에서는 모든 것이 영속성 계층 위에서 만들어지기 때문에 영속성 계층을 먼저 개발해야 되고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 한다.

`절차지향적인 코드를 짰을 때 발생하는 문제` 이다.

## 죽은 도메인

계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다.
- 객체는 수동적이고, 모든 코드가 함수 위주로 돌아간다.
모든 객체는 getter와 setter를 가지고 있고, 수동적으로 돌아갈 확률이 높다. 또한 모든 코드가 함수 위주로 돌아간다. `객체 지향이 아니라, 절차지향적으로 돌아가게 된다.`

> [!warning] 서비스가 사실상 모든 일을 다 처리하는 신과 같은 존재가 된다.
## 규모가 커질수록 확장성이 떨어진다.

> [!success] 결과적으로 이러한단점들로 인해 개발자가 절차 지향적인 사고를 하게된다.
> 그 결과 낮은 Testability & Bad Solid


# 어떻게 개선해야할까?

Service가 하던 역할을 도메인이 처리하도록 위임해야한다.
도메인 레이어를 만들고, 도메인 객체는 어느곳에도 의존하지 않게한다. 이들을 협력시키는 공간이 도메인 객체가 될것이다.
(도메인에서는 계층간 연결된 의존성이 없다. 그렇기 때문에 Mocking의 필요가 없다.)

- 도메인은 testablilty가 높다.

JpaRepository는 Jpa코드를 사용하고 있고, DB와 강결합 되어있다. 그래서 JpaRepository를 테스트 하는것은 h2같은 embedded DB없이는 매우 힘들다.

의존성으로 발생하는 문제는 의존성 역전을 활용하면 해결된다.
![[jpa는 이렇게 쓰렴.png]]
![[repository_interface분리.png]]
이러한 의존성 역전을 통해 테스트  할때 fake를 사용하게 함으로써, Testability를 높일 수 있게 된다.
이렇게 함으로써 Service레이어는 영속성 계층과의 의존 관계가 놀랍도록 약해지게 된다.

`만약 Mysql같은 RDB를 하용하다가, MongoDB로 갈아타게 되더라도 Service코드는 전혀 영향을 받지 않게된다.`

![[아키텍쳐_결과적으로_이렇게.png]]
Controller을 테스트 하기 위한 결합도 약화

# CQRS
`CQRS(Command and Query Responsibility Segregation)`
- 명령과 질의의 책임 분리
- 메소드를 명령과 질의로 나누자. (더 넓게는 클래스 까지도)

- [i] 명령: 일을 시키는 메서드
	- 명령 메서드는 void타입이어야 한다.
	- 편의상 명령 메서드가 `return this`할때도 있는데, 이렇게 되서도 안된다.
- [i] 질의(Qeury)
	- 상태를 물어보는 메소드
	  질의 메소드는 상태를 변경해서는 안된다.

하나의 메소드는 명령이나 쿼리어야 하며, 두 가지 기능을 모두 가져서는 안된다.
명령은 객체의 상태를 변경할 수 있지만, 값을 반환하지 않는다. 쿼리는 값을 반환하지만 객체를 변경하지 않는다.

-> Repository에 CQRS적용해서, Reader와 Writer로 분리