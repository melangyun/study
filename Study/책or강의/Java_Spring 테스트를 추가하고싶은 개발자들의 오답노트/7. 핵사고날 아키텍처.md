테스트와 설걔(아키텍처)는 상호 보완적인 관계이다.
테스트 하기가 힘들다면 아키텍처가 정답을 열려준다. `테스트하기 쉬운 코드가 좋은 코드일 확률이 높다.`
 - 여러가지 방법이 있는데, 어떤 방식으로 개발하는게 더 나은지 모를 때, 사용하기 좋은 명제이다.
 - 실수를 많이 줄일 수 있다.
---
`이키텍처란: 어떤 비즈니스 문제를 해결하기 위해, 준수해야하는 제약을 넣는과정`
아키텍처를 하다보면 <u>왜 굳이 이렇게까지 해야하지?</u> 라는생각이 들기도 한다.
> 다시말해 아키텍처를 성실하게 지키려고 하면 오히려 불편해지기도 한다.
> 따라서 꼭 써야하는 이유가 없다면 쓰지 않는게 맞을수도 있다.

하지만 사람들이 아키텍처를 공부하고, 개선해야 한다고 생각하는 이유는 그만큼 <u>꼭 써야하는 이유가 있기 때문이다.</u>
- [f] 아키텍처 도입 전, 꼭 사용해야 하는 상황을 먼저 이해하고 **구성원 모두 공감을 해야 한다**
구성원들이 문제에 대한 공감이 없으면, 아키텍처는 그냥 장애물 덩어리이다.

> [!tip] 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 가깝다.

- 아키텍트의 목표는 `필요한 시스템을 만들고, 유지보수하는데 투입되는 인력을 최소화` 하는데 있다.
- 아키텍터의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책과 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.
	- 이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.
		- 구현 세부사항이 아니라, `도메인`이 먼저 개발되어야 한다.

![[도메인 중심 설계.png]]
클린아키텍처에서는 이런 세부 사항을 `험블(Humble) 객체`라고 부른다.
테스트하기도 어렵고, 지나치게 세부적인 험블과 도메인은 분리하라고 한다.

> [!tip] 본질과 험블을 구분해야 하는 이유
> DB를 바꾼다고 계산 로직이 변경되면 안된다.

# 어뎁터의 역할

**input 어뎁터**

> 1. HTTP요청을 자바 객체로 매핑
> 2. 권한 검사
> 3. 입력 유효성 검증
> 4. 입력을 유스케이스의 입력 모델로 매핑
> 5. 유스케이스 호출
> 6. 유스케이스의 출력을 HTTP로 매핑
> 7. HTTP응답을 반환

유스케이스 입력 모델에서 했던 유효성 검증을 똑같이 웹 어댑터에서도 구현해야 하는것은 아니다.
대신 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.

**out어뎁터**

> 1. 입력을 받는다.
> 2. 입력을 데이터베이스 포맷으로 매핑한다.
> 3. 입력을 데이터베이스로 보낸다.
> 4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
> 5. 출력을 반환한다.


# 유즈케이스의 중요성

플랫폼에 집착하면 안된다.
- 새로운 언어 / 플랫폼이 나올때마다 매번 그것을 쫓아갈 수는 없다.
도메인과 유즈케이스에 집중하는것이 먼저다.

# 모델
모델은 어디까지 세분화 해야하는가?
- domain entity와 영속성 entity는 다르다. -> 동의

`원칙과 편의성` 사이에는 사실 정답이 없다.

