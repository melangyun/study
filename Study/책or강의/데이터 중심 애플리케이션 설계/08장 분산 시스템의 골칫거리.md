- 하드웨어: `결정적`
	- 완전하게 동작하거나, 전체 장애 발생. 그 중간 상태가 되지는 않음
- 분산시스템: `비결정적`
	- 시스템의 어떤 부분은 잘 동작하지만, 다른 부분은 예측할 수 없는 방식으로 고장

분산 시스템은 어떤 부분에 결함이 생길것이고, 소프트웨어는 어떤식으로든 결함을 처리해야한다.
발생 가능성이 상당히 낮을지라도 생길 수 있는 결함을 광범위하게 고려하고 테스트 환경에서 인위적으로 상황을 만들어 어떤 일이 생기는지 보는게 중요하다.

# 신뢰성 없는 네트워크
인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크다. 이런 종류의 네트워크에서 노드는 패킷을 보낼 수 있지만 네트워크는 메시지의 도착여부는 보장하지 않는다.

이런 문제를 다루는 흔한 방법은 *타임아웃*이다.
- 그러나 타임아웃이 발생했을 때 원격 노드가 응답을 받았는지 아닌지는 여전히 알 수 없다.

==네트워크 결함이 드물더라도 일어날 수 있다는 사실은 소프트웨어가 이를 처리할 수 있어야 한다는 뜻이다== 
네트워크 결함을 모두 견뎌내도록 처리할 필요는 없지만, 소프트웨어가 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야한다.

## 결함 감지
- 요청이 성공했음을 확신하고 싶다면 애플리케이션 자체로부터 긍정 응답을 받아야 한다.
- 역으로 뭔가 잘못되면 일반적으로 아무 응답도 받지 못할 것이라고 가정해야 한다.

## 타임아웃과 기약 없는 지연

- 길면 노드가 죽엇다고 선언될 때까지 기다리는 시간이 길어진다.
- 짧으면 결함을 빨리 발견하지만, 노드가 일시적으로 느려졌을 뿐인데도 죽었다고 선언할 위험 존재

> [!example] 패킷의 최대 지연 시간이 보장된 네트워크를 사용하는 가상의 시스템
> - 모든 패킷 `전송 || 손실 시간 <= d`
> - 정상 `노드 처리 시간 <= r`
> 
> **성공한 요청은 모두 `2d+r`시간 내에 응답을 받는다고 보장할 수 있다.**
> 그렇다면 `2d+r`을 타임아웃 시간으로 사용하는게 합리적이다
> - [c] 하지만 유감스럽게도 우리가 사용하는 시스템 중 어떤 것도 시간을 보장하지 않는다.

## 네트워크 혼잡과 큐 대기
컴퓨터 네트워크에서 패킷 지연의 변동성은 큐대기 때문인 경우가 많다.
아래 요인은 네트워크 지연의 변동성에 영향을 준다.

- 네트워크 혼잡(network congestion)
  네트워크는 잘 동작하고 있더라도 들어오는 데이터가 많아 스위치 큐를 꽉 채울정도가 되면 패킬이 유실되어 재전송해야 한다.
- CPU 코어가 바쁘다면 운영체제 큐
- TCP는 흐름제어를 수행하는데, 노드가 네트워크 링크나 수신 노드에 과부하를 가하지 않도록 송신율을 제한한다 -> 네트워크로 들어가기 전에 부가적인 큐 대기를 할수도 있다. 🙂‍↔️
  TCP는 타임아웃 안에 확인 응답을 받지 않으면 패킷이 손실됫다고 간주하고 패킷은 재전송하기때문에, 그 결과로 인해 지연이 생길 수 있다.

큐 대기 지연은 시스템이 최대 용량에 가까울때 광범위하게 일어난다.

> 지연 변동성이 얼마나 되는지 알아내려면 긴 기간에 여러 장비에 걸쳐서 네트워크 왕복 시간의 분포를 측정해야한다.

그 후 애플리케이션의 특성을 고려, 장애 감지 지연과 너무 이른 타임아웃의 위험성 사이에서 적절한 트레이드 오프를 결정할 수 있다.
- 더 좋은 방법은 고정 타임아웃 대신 시스템이 지속적으로 응답 시간과 변동성(네트워크 통신에서 응답 시간의 변동성)을 측정, 관찰된 응답 시간 분포에 따라 타임아웃을 조절하게 하는것이다.
	- 파이 증가 감지기 (Phi Accrual failure detector) 사용


> [!question] 왜 데이터 네트워크와 인터넷은 패킷 교환을 사용할까?
> 이들은 순간적으로 몰리는 트래픽(bursty traffic)에 최적화 됐기 때문이다.
> - 회선은 정적 방식으로 분배. 하지만 인터넷은 대역폭을 동적으로 공유
> 
> 네트워크에서 변동이 큰 지연은 자연 법칙이 아니라 단지 트레이드 오프의 결과물일 뿐이다


# 신뢰성 없는 시계
분산 시스템에서 시계 동기화는 매우 중요하지만 어려운 문제이다
각 노드가 서로 다른 물리적 위치에 있기 때문에 정확한 시간 동기화를 위해 네트워크 지연, 클록 드리프트 등을 고려해야함

**일기준 시계**
	- NTP(Network Time Protocl)을 통해 (UTC 기준) 시계 동기화
	- 네트워트 지연 등의 이슈로 완벽한 동기화를 보장할 수 없다.

**단조 시계**
- 시간이 항상 증가하도록 보장하며, 이벤트 간 상대적 시간 간격을 측정하는데 적합.
(시계 동기화 문제 x 측정이 부정확해도 민감하지 않음)

> [!summary] 정확한 시계 동기화는 불가능
> 상대적인 시간순서에 의존하는 알고리즘이 사용됨

> 이를 해결하기 위해 Lamport 타임스탬프 혹은 Vector Clock 같은 알고리즘이 제안됨
> - Lamport 타임스탬프: 각 이벤트에 번호를 부여해 비교
> - Vector Clock 보다 정밀하게 이벤트간 종속성 파악
> - LWW(Last Write Wins): 최신 값을 기준으로 데이터 충돌 해결.
>   단, 데이터가 최신이라도 순서는 보장이 되지 않는다

## 프로세스 중단
분산 시스템에서는 리더 노드가 특정 작업을 책임지는데, 리더 노드의 중단이 전체 시스템에 큰 영향을 미칠 수 있다. 하지만 프로세스가 중단되는 일은 필연적임
- 장애 발생시 새로운 리더를 선출해야한다
- 리더 임차권(Lease)를 활용해 일정 시간동안 특정 노드가 리더 역할을 맡도록 보장하며, 임차권 만료시 다른 노드가 리더 역할을 이어받는다
- 하지만 Lease 갱신 중 장애가 발생하면 작업이 중단되거나 데이터 불일치가 발생할 위험이 있다
  이를위해 항상 임차권 만료 전에 갱신을 시도하거나, 새로운 리더를 선출 필요

**GC 의 영향**
GC로 인해 특정 노드의 작업이 일시적으로 멈출 수 있다 (Stop-the-World)
이 이벤트 동안 애플리케이션의 모든 스레드가 멈추고 GC작업이 완료되기 전까지 노드는 임차권 갱신이나 요청 처리를 할 수 없다.
- 만약 리더 노드가 GC로 인해 중단되면 다른 노드가 임차권 만료를 감지하고 새로운 리더 선출 -> 이중 리더상태의 위험이 될 수 있다.

- [w] 최근에 나온 아이디어
	GC 중단을 노드가 잠시계획적으로 중단되는것으로 간주. 가비지 컬렉션을 하는동안 요청을 다른 노드들이 처리하도록함. > 곧 GC 중단이 필요하다는 경고를 한 수 기다릴 수있음
	- 컬렉션을 빨리 할 수 있는 수명이 짧은 객체만 가비지 컬렉터를 사용하고, 수명이 긴 객체의 전체 GC가 필요할 만큼 객체가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법
이런 조치가 가비지 컬렉션 중단을 완전히 막을 수는 없지만, 애플리케이션에 미치는 영향은 유용하게 줄일 수 있다.
  
## 펜싱토큰(fencing token)
잠금 서버가 잠금이나 임차권 승인시 펜싱토큰 반환한다고 가정
(잠금이 승인될때마다 증가하는 숫자)
- 클라이언트가 쓰기 요청을 저장소 서비스로 보낼 때마다 현재 팬싱 토큰을 포함하도록 요구할 수 있다.
이 값을 바탕으로 유효한 작업만 수행할 수 있도록함

## 정족수(Quorum), 비잔틴 결함(Byzantine fault)
정족수를 통해 여러 노드가 동의한 작업만 유효하도록 보장

일부 노드가 오작동하고 프로토콜을 준수하지 않거나, 악의적 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 비잔팀 내결함성을 가진다.

하지만 비잔틴 결함 환경에서는 악의적 노드가 잘못된 정보를 퍼뜨릴 가능성이 있어 더 복잡한 알고리즘이 필요

## 시스템 모델
• 동기식, 비동기식, 부분 동기식 모델이 있음
현실 시스템은 `죽으면 복구하는 결함`을 지닌 `부분 동기식 모델`이 일반적으로 가장 유용한 모델

> [!question] 동기식?
> 분산시스템에서 `동기적` 이라는건 `시간적 동작에 대한 제약조건`
> - 동기식 모델
> 	- 모든 프로세스가 예측 가능한 시간 안에 작업을 완료한다고 가정
> 	- 네트워크 지연도 일정하며, 시스템이 항상 동작 시간 내에 결과를 반환할 것이라 보장
> - 비동기식
> 	- 작업 완료 시간과 네트워크 지연에 대한 제한이 없다고 가정
> 	- 무한히 긴 시간이 걸릴수도. 요청에 대한 응답이 언제 올지 보장할 수 없음
> - 부분동기식
> 	- 대부분 경우 지연 시간이 제한시간 내에 있지만 때때로 예외가 발생할 수 있음
> 	- 안정적인 상황에서는 동기식으로 동작, 불안정할 때는 비동기식으로 동작

- 죽으면 복구하는 결함
	- 노드가 어느 순간에 죽을 수 있지만, 시간이 흐른 후에는 아마도 다시 응답하기 시작할 것이라고 가정.
	  -> 메모리에 있는 상태는 손실되지만, 비휘발성 디스크 저장소가 있다 가정

## 시스템 모델 현실 세계에 대응시키기

이론적으로 완벽한 알고리즘도 현실의 물리적 한계, 버그, 장애 등으로 항상 기대대로 작동하지 않는다. 따라서 시스템 설계시 가정과 실제 구현의 간극을 인지하고 대비해야한다.
일부 예외적인 상황은 개발자가에 직접 알려주는 방식으로 처리될수도 있다