과거 모놀리틱 서비스에서 애플리케이션 개발을 위해 가장 많이 사용된 데이터베이스는 관계형 데이터베이스였다. 관계형 데이터 베이스는 고정된 스키마를 갖고 있다.
하지만 최근 서비스에서는 정해진 형태가 없고, 크기와 구조를 예측할 수 없는 비정형 데이터가 증가하고 있다. 비정형 데이터는 다차원적이거나 깊은 계층 구조를 가질 수 있어 관계형 데이터베이스의 정형화된 테이블에서는 관리하기 어렵다.

> RDB가 활용가치가 없는것은 절대 아니나, 비즈니스 특성과 데이터의 형태를 고려하지 않고 RDB만을 고집하면 복잡하고 비효율적인 데이터 모델을 갖는 시스템이 될 수 있는것이다.

- [i] 마이크로서비스 아키텍처에서 가장 중요한 것은 각 서비스가 독립적으로 동작할 수 있도록 하나의 서비스가 다른 서비스들과 밀접하게 연관되지 않아야 한다.
서비스는 스스로의 상태를 유지해야 하며, 이를 위해 독립된 저장소가 필요하다.
- 각 서비스는 각각 하나의 역할을 수행하기 위해 설계된 독립적인 파트이기 때문에, 서비스별 비즈니스 특성과 데이터의 형태를 고려해 관계형 DB또는 NoSQL을 선택해서 사용할 수 있다.

# NoSQL?
`Not only SQL`
NoSQL에도 여러 타입이 존재하는데, RDB와는 다르게 관계가 정의돼 있지 않은 데이터를 저장한다는 공통적인 특징이 있다.

## 대부분 Nosql이 갖고있는 일반적인 특징

1. 실시간 응답
2. 확장성
3. 고가용성
4. 클라우드 네이티브
5. 단순성
6. 유연성

# NoSQL데이터 저장소 유형
`이전 비교글:` [[SQL vs noSQL]]

## 그래프 유형

![Nosql 그래프 유형](https://bi-insider.com/wp-content/uploads/2019/01/Graph-Database.png)
노드(node), 에지(edges), 속성(properties)
- 노드: 데이터 엔티티
- 엣지: 데이터 사이의 관계
	  엣지는 항상 시작, 끝 노드, <u>유형과 방향을 가지며</u> 상-하위 관계, 동작, 소유자 등의 정보를 저장한다.

> 그래프 유형의 DB는 관계를 저장하고 표현할 때 유용하게 사용될 수 있으며, <u>저장되는 속성의 크기가 크거나, 혹은 매우 많은 속성을 저장할때는 적합하지 않다.</u>

그래프 유형의 DB는 추천 서비스에서 유용하게 사용될 수 있다.
(쇼핑몰에서 관심 분야나, 구매 이력이 비슷한 다른 유저가 구입한 제품을 파악해 관심이 있어 할 만한 상품을 추천해줄 수 있는 기능 등)

> [!question] 그러나, 구매이력 기반 추천이나 추천 알고리즘 자체가 상당한 데이터를 필요로 하는게 아닐까? 🤔
> **🤖 ANSWER:** 
> 그래프 유형의 데이터베이스(Graph Database)는 저장되는 속성의 크기나 매우 많은 속성을 저장할 때 반드시 부적합한 것은 아닙니다. 실제로 그래프 DB는 매우 복잡한 관계 데이터를 저장하고 처리하는 데 강력한 도구가 될 수 있습니다. 이는 노드와 엣지로 이루어진 데이터 모델을 사용하여 데이터 간의 관계를 효율적으로 표현하고 쿼리할 수 있기 때문입니다.
구매 이력 기반의 추천 알고리즘의 경우, 그래프 DB는 다양한 이유로 적합할 수 있습니다
> 1. **복잡한 관계 표현**: 구매 이력, 사용자 선호도, 상품 간의 유사성 등을 그래프 형태로 표현하기에 적합합니다. 이를 통해 다양한 관계를 효율적으로 탐색할 수 있습니다.
> 2. **고속 쿼리**: 그래프 DB는 복잡한 관계를 빠르게 쿼리할 수 있어, 추천 시스템의 성능을 높일 수 있습니다. 이는 특히 그래프 탐색을 통해 사용자와 상품 간의 유사성을 찾는 데 유리합니다.
> 3. **유연한 데이터 모델**: 그래프 DB는 스키마가 고정되지 않아, 새로운 속성을 쉽게 추가하거나 변경할 수 있습니다. 이는 추천 알고리즘이 발전함에 따라 데이터를 유연하게 확장할 수 있도록 도와줍니다.
> 4. **확장성**: 대규모 데이터를 처리할 때 그래프 DB는 수평적 확장이 용이합니다. 이는 대량의 데이터를 효과적으로 처리하고 저장할 수 있는 능력을 의미합니다.
> 
그래프 DB가 부적합하다고 느낄 수 있는 상황은, 단순한 속성 데이터의 저장과 같이 그래프의 장점을 최대한 활용하지 않는 경우일 수 있습니다. 그러나 추천 알고리즘과 같은 복잡한 데이터 관계를 처리하는 데에는 그래프 DB가 강력한 솔루션이 될 수 있습니다.

## 칼럼 유형ㅋ
![칼럼 유형](https://learning-notes.kovacevic.dev/assets/images/column-database-c639736f7b62161d3c1b7a790408d031.png)

> [!info] 칼럼 유형의NoSQL은 `행`이 나닌 `열`을 기준으로 저장한다.
> 하나의 열에 중첩된 키-값 형태로 저장될 수 있기 때문에 기존의 RDB와 비교해씅ㄹ 때 보다 유연한 스키마를 저장할 수 있다.

대량의 데이터에 대한 집계 쿼리를 다른 유형보다 훨씬 빠르게 처리할 수 있어, 기업의 BI분석을 위한 데이터 웨어하우스에서 유용하게 사용될 수 있다.

- [k] Apache Cassandra, HBase

## 문서 유형
문서 유형의 DB는 JSON형태로 데이터가 저장돼 개발자들이 편하게 사용할 수 있는 구조다.개발자들의 프로그램 코드와 동일한 형태로 데이터가 저장돼, 효율적이고 직관적으로 데이터를 사용할 수 있다.

대표적으로 `MongoDB, CouchDb, DocumentDB`등 이 있다.

## 키 - 값 유형
![key-value](https://www.scylladb.com/wp-content/uploads/Key-Value-Store-diagram-1-e1644958335886.png)
키-값 유형은 가장 단순하고 빠르다. 모든 값은 키에 연결되어 있으며 <u>키 자체도 유의미한 데이터다.</u>
키를 사용해 값을 검색할 수 있으며, 키를 삭제하면 값도 삭제된다.

DB의 저장이 간단하기 때문에 다른 유형보다 수평적 확장이 쉽다. 구조의 단순성으로 인해 빠른 데이터 액세스와 처리 속도를 보장해준다.

#  레디스란?
`Remote dictionary server`
- 고성능 키-값 유형의 <u>인메모리 Nosql 데이터 베이스</u>

## 레디스 특징
![in memory db](https://hazelcast.com/wp-content/uploads/2021/12/In-Memory-Database-Diagram_v0.1.png)

## 실시간 응답(빠른 성능)  

온디스크 형태의 DB는 영구적으로 디스크에 저장된다. 자주 사용되는 데이터는 메모리에 저장되어 데이터를 찾고자 할때 디스크에 가서 데이터를 검색하는 과정을 거쳐야 한다.
> 이때 디스크에 저장된 데이터는 바로 찾을 수 없으며, ==디스크의 데이터를 페이지 단위== 로 메모리에 올린 뒤 메모리에서 데이터를 찾고, 없는 경우 다른 페이지를 디스트에서 가져와 메모리에 올린 뒤 찾는 과정을 반복한다.

디스크에 접근하는 속도는 메모리에 접근하는 속도보다 현저히 느리다. <u>디스크에 접근하는 빈도가 증가할 수록 시스템 성능은 저하된다.</u>

- [p] 인메모리 형태의 DB에서는 모든 데이터가 메모리에서 관리된다. 

## 단순성
![레디스 자료구조](https://blog.kakaocdn.net/dn/bsxKIM/btqE9u1RqHA/pd48khq1lAJsdtcbg3LsE1/img.png)

레디스는 key-value형태로 다양ㅇ한 데이터 구조를 저장할 수 있도록 지원한다.
레디스는 내장된 다양한 자료 구조를 통해 임피던스 불일치를 해소하고 개발을 편리하게 할 수 있도록 지원한다.

![레디스는 싱글스레드](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7ca7545a-2a0d-4fee-96cb-62a4a04470d3_1752x838.png)
**레디스는 이벤트 루프를 이용한 싱글 스레드로 동작한다**
메인 스레드 1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다. 최소 하나의 코어만 있어도 레디스를 사용할 수 있어 배포가 쉬우며, CPU가 적은 서버에서도 좋은 성능을 낼 수 있다.
또한 멀티스레드 애플리케이션에서 요구되는 동기화나 잠금 매커니즘이 없이도 안정적이고 빠르게 사용자 요청을 처리할 수 있다.

- [!] 그러나 <u>한 사용자가 오래 걸리는 커맨드를 수행한다면, 다른 사용자는 그 쿼리가 완료될 때 까지 대기할 수 밖에 없다</u>
	이러한 특징으로 인적 장애가 발생할 가능성이 매우 높다.

> [!question] 레디스는 왜 싱글스레드로 설계되었을까?
>**ANSWER**🤖 : 
>1. 단순성:
> 	- 싱글스레드 설계는 코드의 단순성을 유지하는 데 도움이 됩니다. 멀티스레드 환경에서 발생할 수 있는 복잡한 동기화 문제를 피할 수 있습니다.
> 2. I/O 멀티 플랙싱
> 	- 레디스는 I/O 멀티 플렉싱을 사용하여 다수의 클라이언트 연결을 효율적으로 처리합니다.
> 	  이는 `enpoll`, `kqueue`같은 비차단 방식의 시스템 호출을 활용하여 이루어집니다. 덕분에 싱글스레드로 높은 성능을 유지할 수 있습니다.
> 3. 메모리 효율 접근성
> 	- 동시에 여러 스레드가 메모리에 접근하지 않기 때문에 캐시 미스가 줄어들고, 메모리 접근이 더 효율적입니다.
> 4. 경합 없음
> 	- 여러 스레드가 동시에 데이터를 접근하려고 할 대 발생할 수 있는 경합을 피할 수 있습니다.
> 	  이는 데이터 일관선 유지와 성능 저하 방지에 도움이 됩니다.
>   5. 쉬운 디버깅
> 	 - 동기화 문제나 데드락 같은 멀티스레드 특유의 버그를 걱정할 필요가 없습니다.
>  6. 대부분의 작업이 빠르게 완료
> 	 - 레디스에서 수행되는 대부분 작업은 매우 짧은 시간 내에 완료됩니다. 따라서 작업을 순차적으로 처리하더라도 성능에 큰 문제가 없습니다.

## 고가용성 HA
자체적으로 고가용성 기능을 제공한다. 복제를 통해 데이터를 여러 서버에 분산시킬 수 있으며, 센티널`sentinel`은 장애 상황을 탐지해 자동으로 페일오버를 시켜준다.

애플리케이션이 센티널을 이용해 레디스에 연결하는 구조에서는 마스터에 장애가 발생하더라도, 레디스로의 엔드포인트를 변경할 필요 없이 페일오버가 완료되어 정상화된 마스터 노드를 사용할 수 있다.


## 확장성
![레디스 클러스터](https://velog.velcdn.com/images/ekxk1234/post/f2ce167b-2496-4a94-94f7-3c26ffffd60f/image.png)

레디스에서 클러스터 모드를 사용하면, 손쉬운 수평적 확정이 가능하다.
레디스는 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러개의 복제본이 생성될 수 있다. 클러스터 구조에서 모든 레디스 인스턴스는 ==클러스터 버스라==는 프로토콜을 이용해 서로 감시하고 있으며, 이를 이용해 클러스터의 마스터 노드에 문제가 발생하면 자동으로 페일오버를 시켜 고가용상을 유지할 수 있다.


## 클라우드 네이티브 멀티클라우드
- 클라우드 네이티브 - 클라우드 환경에 특화된 애플리케이션 개발 및 운영방식
  레디스는 클라우드 네이티브 환경에서 빠른 데이터 액세스 및 처리를 지원하는 구조로 인해 MSA와 연계에서 큰 장점을 지닌다.
- 멀티 클라우드 - 여러 클라우드 제공 업체의 서비스를 동시에 혹은 혼합해 활용하는 전략
  제한된 자원에 대한 의존성을 줄이며, 각 클라우드 서비스 제공자의 강점을 활용할 수 있게 해준다. 

# MSA와 레디스

## 데이터 저장소로서의 레디스

레디스는 설치가 간편하고, 최소한의 리소스로 막대한 처리량을 낼 수 있으며, 다향한 자료구조를 제공하면서도 사용이 간단하기 때문에 MSA의 요구사항에 맞는 데이터를 저장하기도편하다.
	- 또, ==고가용성을 위한 로드 밸런서나 프록시 등 추가적인 서비스를 설치할 필요가 없어 하나의 저장소로서 역할을 수행하기에 충분하다==
	- 레디스의 데이터가 영구 저장되지 않기때문에 데이터 저장소로 사용하기 위해 데이터 영속성을 고민할 수 있으나, 레디스의 데이터는 [[AOF(Append Only File)]]와 RDB형식으로 디스크에 주기적으로 저장할 수 있다.
	  -> 레디스에 장애가 발생해 데이터가 유실되더라도 백업 파일을 이용하면 다시 복구가 가능하다.

## 메시지 브로커로서의 레디스

**Pub/sub**
레디스의 `Pub/sub`기능은 가장 간단한 매시징 기능으로, 굉장히 빠르게 동작하며 간단히 사용할 수 있다.
- [c] 하지만 pub/sub에서 모든 데이터는 전달된 뒤 삭제되는 <u>일회성</u>으로, 모든 메시징 상황에 적합하지는 않다.
- [p] `fire and forget`패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용할 수 있다.


**list자료구조**
메시징 큐로 사용하기 알맞다. list에서는 빠르게 push/pop을 할 수 있으며, 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 list에 새로운 데이터가 들어오면 읽어 갈 수 있는 블로킹 기능을 사용할 수도 있다.

**stream 자료구조**
레디스를 완벽한 스트림 플랫폼으로 사용할 수 있다. stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료구조로, 데이터는 계속해서 추가되는 방식으로 저장한다.(append-only)
> 카프카처럼 저장되는 데이터를 읽을 수 잇는 소비자와 소비자 그룹이 존재해 데이터의 분산 처리도 가능하며, 저장된 데이터를 시간대별로 검색하는 것도 가능하다.


