레디스는 key-value형태의 데이터 저장소이며, <u>레디스에서 모든 데이터는 키에 연결돼 있기 때문에 데이터를 저장하고 저장된 데이터를 검색할 때에는 항상 키를 식별자로 이용한다.</u>
데이터는 레디스에서 제공하는 다양한 형태의 자료구조로 저장될 수 있다.

# 레디스의 자료구조

## String
string은 레디스에서 데이터를 저장할 수 있는 가장 간단한 자료 구조다. string에서는 최대 `512MB`의 문자열 데이터를 저장할 수 있으며, 이진 데이터를 포함하는 모든 종류의 문자열이 binary-safe하게 처리되기 때문에 JPEG이미지와 같은 바이터 값, HTTP응답값 등의 다양한 데이터를 저장하는 것도 가능하다.

> [!info] string은 키와 실제 저장되는 아이템이 일대일로 연결되는 유일한 자료구조.
> string이 아닌 다른 자료 구조에서는 하나의 키에 여러개의 아이템이 저장된다.

```redis
SET hello world
```
- [f] 만약 hello라는 키에 다른 값이 연결돼 있다면 기존 값은 새로 입력된 값으로 대체되며, 저장된 값이 같은 string형태가 아닌 다른 형태의 자료구조라도 동일하게 동작한다.

**NX옵션 - 지정한 키가 없을 때에만 새로운 키를 저장한다.**

```redis-cli
SET hello newval NX
(nil)
```
새로운 값이 저장되지 않는다.

**XX옵션 - 키가 있을때에만 새로운 값으로 덮어 쓴다.**

string자료 구조는 모든 문자열 데이터를 저장할 수 있기 때문에 당연히 숫자 형태의 데이터를 젖아하는것도 가능하다.

- **INCR, INCRBY와 같은 커맨드를 이용하면 string 자료 구조에 저장된 숫자를 원자적으로 조작 할 수 있다.**
> [!info] 커맨드가 원자적이라는 것은 같은 키에 접근하는 여러 클라이언트가 경쟁상태(race condition)을 발생시킬 일이 없음을 의미한다.
> 커맨드가 수행하는 타이밍이나 순서에 따라 이미 실행한 커맨드가 무시되거나 같은 커맨드가ㅣ 중복 처리돼 수행 결과가 달라지는 일은 발생하지 않는다.

> incr: 발생시 - 읽고 - 증가하고- 저장하는 일련의 과정은 원자적으로 발생한다.
>이 과정을 수행할 때 다른 클라이언트가 이 키에 접근할 수 없음을 보장한다.


**MSET, MGET 커맨드를 이용하면 한 번에 여러 키를 조작할 수 있다.**
```redis-cli
MSET a 10 b 20 c 30

MGET a b c
```

MSET과 MGET과 같은 커맨드를 적절하게 사용해 네트워크 통신 시간을 줄인다면 전반적으로 서비스의 응답 속도를 확실하게 향상시킬 수 있게된다.


# List
레디스에서 list는 순서를 가지는 <u>문자열의 목록</u>이다.
하나의 list에는 최대 42억 개의 아이템을 저장할 수 있다. 배열처럼 인덱스로 접근할 수도 있으며, 서비스에서 <u>스택과 큐</u>로 활용할 수도 있다.
- **LPUSH**: list왼쪽에 데이터 추가
- **RPUSH**: list의 오른쪽에 데이터를 추가
- **LRANGE**: list 데이터 조회
- **LTRIM**: 커맨드 시작과 끝 아이템의 인덱스를 인자로 잔달받아 지정한 범위에 속하지 않는 아이템 모두 삭제
	- 그러나 **LPOP**과 같이삭제되는 아이템을 반환하지는 않는다.

- [i] LPUSH와 LTRIM 커맨드를 함께 이용하면 고정된 길이의 큐를 쉽게 유지할 수 있다.
```redis-cli
LPUSH logdata <data>
LTRIM logdata 0 999
# 1000개 까지는 LTRIM해도 아무일도 일어나지 않는다.
```

> [!tip] 로그 데이터는 일단 쌓은 뒤 주기적으로 배치 처리를 이용해 삭제하는 것보다 위와 같은 방식으로 삭제하는 것이 훨씬 효율적이다.
위 작업은 매번 큐의 마지막 데이터만 삭제되기 때문. O(1)로 동작하기 때문에 굉장히 빠르게 처리되며, 배치시다다 삭제할 데이터를 검색하는것 보다 효율적이다.

> [!summary] list의 양 끝에서 데이터를 넣고 빼는 LPUSH, RPUSH, LPOP, RPOP 커맨드는 O(1). 인덱스나 데이터를 이용해 list에 접근할 때는 O(n)
> 또한 데이터가 늘어남에 따라 성능은 저하된다.

- **LINSERT** : 커멘드는 원하는 데이터의 앞이나 뒤에 데이터를 추가할 수 있다.
	데이터의 앞에 추가하려면 BEFORE 옵션을, 뒤에 추가하려면 AFTER옵션을 추가하면 된다. 만약 지정한 데이터가 없으면 오류를 반환한다.

# Hash
- **HSET**: hash에 아이템을 저장할 수 있다.
  한번에 여러 필드 - 값 쌍을 저장할 수도 있다.
```redis-cli
> HSET Product:123 Name "Happy Hacking"
(integer) 1

> HSET Product:234 Name "Track Ball" TypeId 32
> (integer) 2
```

- **HGET**: 커맨드로 가져올 수 있다.
  이 때 hash 자료구조의 키와 아이템 필드를 함께 입력해야 한다.
  - **HMGET** 커맨드를 이용하면 하나의 hash내에서 다양한 필드의 값을 가져올 수 있따.
  - **HGETALL** 커맨드는 hash내의 모든 필드 - 값 쌍을 차례로 반환한다.

# SET
레디스에서 set은 정렬되지 않은 문자열의 모음이다. 아이템은 중복해서 저장되지 않으며, 교집합, 합집합, 차집합 등의 집합 연산과 관련한 커맨드를 제공하기 때문에 객체 간의 관계를 계산하거나 유일한 원소를 구해야 할 경우 사용될 수 있다.

- **SADD**: set에 아이템을 저장할 수 있다. 한 번에 여러 개의 아이템을 저장하는것도 가능하다.
	- 저장되는 실제 아이템 수를 반환한다.
- **SMEMBERS** 커맨드는 set자료구조에 저장된 전체 아이템을 출력하는데, 이 때 데이터를 저장한 순서와 관계 없이 랜덤한 순서로 데이터가 출력되는 것을 확인할 수 있다.
- **SREM**: set에서 원하는 데이터를 삭제할 수 있다.
- **SPOP**: 커맨드는 set 내부의 아이템 중 랜덤으로 하나의 아이템을 반환하는 동시에 set에서 그 아이템을 삭제한다.

```redis-cli
> SREM myset B
(integer) 1

> SPOP myset
"E"
```
- 합집합은 SUNION
- 교집합은 SINTER
- 차집합은 SDIFF
커맨드로 수행할 수 있다.

# sorted Set
sortedSet은 스코어(score)값에 따라 정렬되는 고유한 문자열의 집합이다. 3-11과 같이 모든 아이템은 스코어-값 쌍을 가지며, 저장될 때 부터 스코어 값으로 정렬돼 저장된다.
같은 스코어를 가진 아이템은 ==사전 순==으로 정렬되 저장된다.

데이터는 중복이 없어 set과 유사하며, 각 아이템은 스코어라는 데이터에 연결돼 있어 이 점에서 hash와 유사하다고 할 수 있다.
또, 모든 아이템은 스코어 순으로 정렬돼 있어, list처럼 인덱스를 이용해 각 아이템에 접근할 수 있다.

- **ZADD**: sorted set에 아이템을 저장할 수 있다.
  스코어-값 쌍으로 입력해야한다.
	- 여러 아이템을 한번에 입력할 수 있으며, 저장되는 동시에 <u>스코어 값으로 정렬된다.</u>
```redis-cli
> ZADD score:220817 100 user:B
(integer) 1
> ZADD score:220817 150 user:A 150 user:C 200
(integer) 3
```

- [!] 만약 데이터가 이미 속해있다면, 스코어만 업데이트 되며, 업데이트된 스코어에 의해 아이템이 재정렬된다.
	- 키가 이미 존재하지만, sorted set이 아닐경우 오류를 반환한다.
	- 스코어는 배정밀도 부동소수점 숫자를 문자열로 표현한 값이어야 한다.

- **XX**: 아이템이 이미 존재할 때만 스코어를 업데이트 한다.
- **NX**: 아이템이 존재하지 않을 때에만 신규 삽입.
	- 기존 아이템의 스코어를 업데이트 하지 않는다.
- **LT**: 업데이트 하고자 하는 스코어가 기존 아이템의 스코어보다 작을 때에만 업데이트한다.
- **GT**: 업데이트 하고자 하는 스코어가 기존 아이템 스코어보다 클 때만 업데이트한다.
- **ZRAMGE** 커맨드를 사용하면 sorted set에 저장된 데이터를 조회할 수 있으며, **start**와 **stop** 범위를 항상 입력해야 한다.
	- WITHSCORE: 데이터와 함께 스코어 값이 차례대로 출력된다.
	- REV옵션 사용시 데이터는 역순으로 출력된다.

## 사전 순으로 데이터 조회
스코어가 같으면 데이터는 사전 순으로 정렬된다. 이러한 특성을 사용해 스코어가 같으면 `BYLEX`옵션을 사용해 사전 순서를 이용, 특정 아이템을 조회할 수 있다.
- 문자열은 ASCII 바이트 값에 따라 사전식으로 정렬되기 때문에, 한글 문자열도 이 기준에 따라 정렬하거나 사전식으로 검색 할 수 있다.

# Hyperloglog
집합의 원소 개수인 `카디널리티`를 추정할 수 있는 자료구조
대량 데이터에서 중복되지 않는 고유한 값을 집계할 때 유용하게 사용할 수 있다.

일반적으로 set과 같은 데이터 구조에서는 중복을 피하기 위해 저장된 데이터를 모두 기억하고 있으며, 따라서 저장되는 데이터가 많아질수록 그만큼 많은 메모리를 사용한다.
hyperLonglong은 입력되는 데이터를 그 자체에 저장하지 않고 자체적인 방법으로 데이터를 처리해 변경한다. <mark style="background: #D2B3FFA6;">따라서 저장되는 데이터 개수에 구애받지 않고 계속 일정한 메모리를 유지할 수 있으며, 중복되지 않는 유일한 원소 개수를 구할 수 있다.</mark>

최대 12KB크기를 가지며, 레디스의 카디널리치 추정의 오차는 0.81%로 비교적 정확하게 데이터를 추정할 수 있다.
하나의 hyperloglog에는 최대 2<sup>64</sup> 개 아이템을 저장할 수 있다.

```redis-cli
PFADD members 123
PFADD members 500
PFADD members 12
PFCOUNT members
(integer) 3
```

# 레디스에서 키를 관리하는법

## 키의 자동 생성과 삭제

stream이나 set, sorted set, hash와 같이 하나의 키가 여러 개의 아이템을 가지고 있는 자료 구조에서는 명시적으로 키를 생성하거나 삭제하지 않아도 키는 알아서 생성되고 삭제된다.
키의 생성과 삭제는 세 가지 공통적인 규칙을 따른다.

1. 키가 존재하지 않을 때 아이템을 넣으면 아이템을 삽입하기 전에 빈 자료구조를 생성한다.
	- 저장하고자 하는 키에 다른 자료 구조가 이미 생성돼 있을 때 아이템을 추가하는 작업은 에러를 반환한다.
2. 모든 아이템을 삭제하면 키도 자동으로 삭제된다.
	- stream은 예외이다.
	- mylist의 모든 아이템을 삭제하면 키 자체가 사라진다.
3. 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 에러를 반환하는 대신 키가 있으나 아이템이 없는 것처럼 동작한다.

# 키와 관련된 커맨드

- 키 조회
	- `EXISTS key [key ...]`
		- 존재하면 1을, 존재하지 않으면 0을 반환한다.
	- `KEYS pattern`
		- 패턴은 `글롭 패턴 스타일`로 동작한다.
- 키 삭제
	- `FLUSH [ASYNC|SYNC]`
		- 기본 FLUSH는 SYNC한 방식으로 동작해 모든 데이터가 삭제된 경우에만 OK를 반환해서 커맨드가 실행되는 도중에는 다른 응답을 처리할 수 없다.
		- ASYNC옵션을 사용하면 flush는 백그라운드로 실행되고, 커맨드가 수행됐을 때 존재했던 키만 삭제해서 flush 되는 중 새로 생성되는 키는 삭제되지 않는다.

> [!tip] 키 삭제시 UNLINK를 사용하는것이 좋다.
> UNLINK는 백그라운드에서 다른 스레드에 의해 처리되며, 우선 키와 연결된 데이터의 연결을 끊는다.
> ==set, sorted set==과 같이 하나의 키에 여러 개의 아이템이 저장된 자료 구조의 경우 1개의 키를 삭제하는 DEL커맨드로 삭제하는 것은 위험하다.
> - 수행되는 시간동안 다른 클라이언트는 아무런 커맨드를 사용할 수 없다.
> - 저장된 아이템이 많은 경우 DEL이 아니라 UNLINK를 사용해 데이터를 삭제하는것이 좋다.
