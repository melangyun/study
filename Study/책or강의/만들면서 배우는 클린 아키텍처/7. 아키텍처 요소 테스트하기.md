# 테스트 피라미드

![테스트 피라미드](https://kooku0.github.io/assets/images/7.1-052d9aa2f7f44ca0b7e5bb0d5e39a7de.jpeg)

> [!info] 만드는 비용이 적고, 유지보수 하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다.
> 여러 개의 단위와 단위를 넘는 경계, 아키텍처의 경계, 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸고, 실행이 더 느려지며, 깨지기 더 쉬워진다.
> - 테스트가 비쌀수록 테스트 커버리지 목표는 낮게 잡아야 한다
>   그렇지 않다면 새로운 기능을 만드는 것보다 테스트를 만드는 데 시간을 더 쓰게 된다.

## 단위테스트

단위테스트는 피라이드의 토대에 해당한다.
일반적으로 하나의 클래스를 인스턴스화 하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다.
만약 테스트중인 클래스가 다른 클래스에 의존한다면 의존되는 클래스들은 인스턴스화하지 않고 테스트하는 동안 필요한 작업을 흉내내는 목(mock)으로 대체한다.

## 통합테스트

이 테스트는 <u>연결된 여러 유닛을 인스턴스화하고, 시작점이 되는 클래스 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증</u>한다.
이 책에서 정의한 통합 테스트에서는 두 계층 간의 경계를 걸쳐서 테스트할 수 있기 때문에 객체 네트워크가 완전하지 않거나 어떤 시점에는 목을 대상으로 수행해야 한다.

## 시스템 테스트

애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.
UI를 포함하는 엔드 투 엔드(end-to-end)테스트 층이 있을 수 있다.

시스템 테스트는 여러 개의 유스케이스를 결합해서 시나리오를 만들 때 더 빛이 난다. 각 시나리오는 사용자가 애플리케이션을 사용하면서 거쳐갈 특정 경로를 의미한다.
> 시스템 테스트를 통해 중요한 시나리오들이 커버된다면 최신 변경사항들이 애플리케이션을 망가뜨리지 않았음을 가정할 수 있고, 배포할 준비가 됐다는 확신을 가질 수 있다.

> [!warning] 테스트에서 어떤 상호작용을 검증하고 싶은지 신중하게 생각해야한다.
> 모든 동작을 검증하는 대신, 핵심만 골라 집중해서 테스트하는 것이 좋다.
> 만일, 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 한다. 이는 테스트의 가치를 떨어뜨리는 일이다.

# 통합 테스트로 영속성 어댑터 테스트하기

영속성 어댑터의 테스트에는 단위 테스트보다는 통합 테스트르 적용하는 것이 합리적이다. 단순히 어댑터의 로직만 검증하고 싶은게 아니라, 데이터베이스 매핑도 검증하고 싶기 때문이다.

```java
// 스프링 데이터 리포지토리들을 포함해서 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화해야 한다고 스프링에 알려준다.
@DataJpaTest
@Import({AccountPersistenceAdapter.class, AccountMapper.class})
// 특정 객체가 이 네트워크에 추가됐다는것을 명확하게 표현할 수 있다.
class AccountPersistenceAdapterTest{
@Autowired
private AccountPersistenceAdapter adapter;

@Autowired
private ActivityRepository activityRepository;

@Test
@Sql("AccountPersistenceAdapterTest.sql")
void loadsAccount(){
	Account account = adapter.loadAccount(
		new AccountId(1L),
		LocalDateTime.of(2018, 8, 10, 0, 0)
	);
	assertThat(account.getActivityWindow().getActivities()).hasSize(2);
	assertThat(account.calculateBalance()).isEqualtTo(Money.of(500))
}

@Test
void updatesActivites(){
	Account account = defaultAccount()
		.withBaselineBalance(Money.of(555L))
		.withActivityWindow(new ActivityWindow(
			.defaultActivity()
			.withId(null)
			.withMoney(Money.of(1L)).build()
		)).build();
	adapter.updateActivities(account);

	assertThat(activityRepository.count()).isEqualTo(1);
	
	ActivityJpaEntity savedActivity = activityRepository.findAll().get(0);
	assertThat(savedActivity.getAmount()).isEqualTo(1L);
}

}
```

이 테스트에서는 데이터베이스를 모팅하지 않았다는 점이 중요하다.
테스트가 실제로 데이터베이스에 접근한다. 데이터베이스를 모킹했더라도 테스트는 여전히 같은 커버리지를 보여줬을 것이다. 하지만, `SQL 구문의 오류나 DB 테이블간의 매핑 에러`등으로 문제가 생길 확률이 크다.

> [!info] 스프링에서는 기본적으로 인메모리(in-memory)데이터 베이스를 테스트에서 사용한다.
> 아무것도 설정할 필요 없이 곧바로 테스트할수 있으므로, 아주 실용적이다.
> > 하지만 운영환경에서 DB와는 차이가 있을 수 있기 때문에, 문제가 있을 가능성이 있다.

>[!check] 이러한 이유로 영속성 어댑터는 실제 DB대상으로 진행해야 한다.

# 얼마만크의 테스트가 충분할까?

라인 커버리지는 테스트 성공을 측정하는 데 있어서 잘못된 지표다.
코드의 중요한 부분이 전혀 커버되지 않을 수 있기 때문에 100%를 제외한 어떤 목표도 완전히 무의미하다. 심지어 100%라고 하더라도, 버그가 잘 잡혔는지 확신할 수 없다.

> [!info] 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 된다고 생각한다.
> 테스트 실행 후 소프트웨어를 배포해도 될 만큼 테스트를 신뢰한다면 그것으로 된것이다. 더 자주 배포할수록 테스트를 더 신뢰할 수 있다.

- 도메인 엔티티를 구현할 때는 단위 테스트로 커버
- 유스케이스를 구현할 때는 단위테스트로 커버
- 어뎁터를 구현할 때는 통합테스트로 커버
- 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버

`구현할 때는` - 만약 테스트가 기능 개발 후가 아닌, 개발 중에 이뤄진다면, 하기 싫은 귀찮은 작업이 아니라 개발 도구로 느껴질 것이다.
> 하지만 새로운 필드를 추가할 때마다 테스트를 고치는 데 한 시간을 써야 한다면 뭔가 잘못된 것이다.
> 아마도 테스트가 코드의 구조적 변경에 너무 취약할 것이므로, 어떻게 개선해야 할지 살펴봐야 한다.
- [!] 리펙터링 할 때마다 테스트 코드도 변경해야 한다면, 테스트는 테스트로서 가치를 잃는다.

---

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

입출력 포트는 테스트에서 아주 뚜렷한 모킹 지점이 된다. 각 포트에 대해 모킹할지, 실제 구현을 이용할지 선택할 수 있다. 만약 포트가 아주 작고 핵심만 담고 있다면 모킹하는 것이 아주 쉬울것이다.

모킹하는 것이 너무 버거워지거나 코드의 특정 부분을 커버하기 위해 어떤 종류의 테스트를 써야할지 모르겠다면, 이는 경고 신호다. 이런 측면에서 테스트는 아키텍처의 문제에 대해 경고하고 유지보수 가능한 코드를 만들기 위한 올바른 길로 인도하는 역할을 한다고도 할 수 있다.