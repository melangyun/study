- 매핑에 찬성하는 측
	두 계층 간에 매핑을 하지 않으면 양 계층에서 같은 모델을 사용해야 하는데, 이렇게 하면 두 계층이 강하게 결합된다
- 매핑에 반대하는 측
	두 계층 간 매핑을 하게 되면 보일러 플레이트 코드를 너무 많이 만들게 된다.
	많은 유스케이스들이 오직 CRUD만 수행하고 계층에 걸처 같은 모델을 사용하기 때문에, 계층 사이의 매핑은 과하다.

# '매핑하지 않기' 전략

![매핑하지 않기 전략](https://velog.velcdn.com/images/jimin3263/post/06ce17b8-cb2e-4047-8dc4-455ec7973f9c/image.png)
> 포트 인터이스가 도메인 모델을 입출력 모델로 사용하면 두 계층 간 매핑을 할 필요가 없다.

웹 계층과 영속성 계층은 모델에 대해 특별한 요구사항이 있을 수 있다. 예를 들어, 웹 계층에서 REST모델을 노출시켰다면 모델을 JSON으로 직렬화 하기위해 애너테이션을 모델 클래스의 특정 필으데 붙여야 할 수도 있다. 영속성 계층에 대해서도 마찬가지이다.
`Account` 클래스는 웹, 애플리케이션, 영속성 계층과 관련된 이유로 변경되어야 하기 때문에, **단일 책임 원칙**을 위반한다.

> [!question] 그럼 '매핑하지 않기' 전략을 절대로 쓰면 안된다는 뜻일까?
> 그렇지는 않다! 지저분할 수 있지만, 전략이 딱 들어맞을 때가 있다.
> 모든 계층이 정확히 같은 구조의 정확히 같은 정보를 필요로 한다면 *완벽한 선택지 이다.*
> 그러니, 같은 정보를 필요로 할때는 그냥 써라

>[!check] 어떤 매핑 전략을 선택했더라도, 나중에 언제든 바꿀 수 있다.
>어떤 매핑전략도 철칙은 아니다.
>각 유스케이스마다 적절한 전략을 선택할 수 있어야 한다.

# '양방향' 매핑 전략

![양방향 매핑 전략](https://velog.velcdn.com/images/jimin3263/post/9febaaa9-f4b4-446d-aecf-0eee25248606/image.png)
> 각 계층이 전용 모델을 가진 매핑 전략을 '양방향(Two-Way)' 매핑 전략이라고 한다.
> 각 어댑터가 전용 모델을 가지고 있어서 해당 모델을 도메인 모델로, 도메인 모델을 해당 모델로 매핑할 책임을 가지고 있다.

두 계층 모두 양방향으로 매핑하기 때문에 '양방향' 매핑이라고 부른다.
'양방향'매핑의 또 다른 장점은 개념적으로는 '매핑하지 않기' 전략 다음으로 간단한 전략이라는 것이다.
**매핑 책임이 명확**하다. 안쪽 계층은 해당 계층 모델만 알면 되고 매핑 대신 도메인 로직에 집중할 수 있다.

- [c] 단점
	1. 너무 많은 보일러 플레이트 코드가 생긴다.
	2. 도메인 모델이 계층 경계를 넘어서 통신하는데 사용되고 있다.
		인커밍 포트와 아웃고잉 포트는 필요에 의해서만 변경되는것이 이상적이지만, 바깥ㅉ/ㅗㄱ 계층의 요구사항에 취약해진다.



# '완전' 매핑 전략

![완전 매핑 전략](https://velog.velcdn.com/images/jimin3263/post/c17099b7-1094-4b36-8388-429849979203/image.png)
> 각 연산이 전용 모델을 필요로 하기 때문에 웹 어댑터와 애플리케이션 계층 각각이 자신의 전용 모델을 각 연산을 실행하는데 필요한 모델로 매핑한다.

각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 가진다.
한 계층을 다른 여러 개의 커맨드로 매핑하는 데는 하나의 웹 모델과 도메인 모델 간의 매핑보다 더 많은 코드가 필요하다. 하지만 이렇게 매핑하면 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현하고 유지보수하기가 훨씬 쉽다.

- [c] 이 매핑 전략을 전역 패턴으로 추천하진 않는다
- [p] 웹 계층과 애플리케이션 계층 사이에 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다.
	> 애플리케이션 계층과 영속성 계층 사이에는 매핑 오버헤드때문에 사용하지 않는것이 좋다.

> 또한 어떤 경우에는 연산의 입력 모델에 대해서만 이 매핑을 사용하고, 도메인 객체를 그대로 출력 모델로 사용하는 것도 좋다.

> [!check] 매핑 전략은 여러 가지를 섞어 쓸 수 있고, 섞어 써야만 한다.
> 어떤 매핑 전략도 모든 계층에 걸쳐 전역 규칙일 필요가 없다.

# '단방향' 매핑 전략

![단방향 매핑 전략](https://velog.velcdn.com/images/jimin3263/post/c7fd2907-241b-4ea8-badf-0e1dfa8d5e34/image.png)
> 동일한 '상태'인 인터페이스를 구현하는 도메인 모델과 어댑터 모델을 이용하면, 각 계층은 다른 계층으로부터 온 객체를 단방향으로 매핑하기만 하면 된다.

이 전략에서는 모든 계층의 모델들이 같은 인터페이스를 구현한다.
이 인터페이스는 관련있는 특성(attribute)에 대한 getter메서드를 제공해서 도메인 모델의 상태를 캡슐화 한다.

도메인 객체를 바깥 계층으로 전달하고 싶으면 매핑 없이 할 수 있다. 왜냐하면 도메인 객체가 인커밍/아웃고잉 포트가 기대하는 대로 상태 인터페이스를 구현하고 있기 때문이다.
그러고 나면 바깥 계층에서는 상태 인터페이스를 사용할지, 전용 모델로 매핑해야 할지 결정할 수 있다.

행동을 변경하는 것이 상태 인터페이스에 의해 노출돼 있지 않기 때문에, 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다.

- 이 매핑 패턴은 팩터리(factory)라는 DDD 개념과 잘 어울린다.
  > 팩터리는 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지고 있다.
  
  이 전략에서 매핑 책임은 명확하다. 만약 한 계층이 다른 계층으로 부터 객체를 받으면 해당 계층에서 사용할 수 있도록 다른 무언가로 매핑하는 것이다.

그러므로, 각 계층은 한방향으로만 매핑한다. -> `단방향` 매핑 전략
이 전략은 계층 간의 모델이 비슷할 때 가장 효과적이다.
> ex) 읽기 전용 연산의 경우 상태 인터페이스가 필요한 모든 정보를 제공하기 때문에, 웹 계층에서 전용 모델로 매핑할 필요가 없다.
# 언제 어떤 매핑 전략을 사용할 것인가?

- [!] 그때그때 다르다!

매핑 전략이 저마다 장단점을 갖고 있기 때문에, 한 전략을 전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 한다.
> 다른 패턴을 섞으면 어수선하게 느껴지긴 하지만, 최선의 패턴이 아님에도, 그저 깔끔하게 느껴진다는 이유로 선택해서는 안된다.


또, SW는 시간이 지나며 변화를 거듭하기 때문에, 어제는 최선이었떤 전략이 오늘은 최선이 아닐 수 있다. 고정된 매핑 전략으로 계속 유지하기 보다는, 빠르게 코드를 짤 수 있는 간단한 전략으로 시작해서 계층 간 결합을 떼어내는 데 도움이 되는 복잡한 전략으로 갈아타는것도 괜찮은 전략이다.

이 같은 가이드라인을 성공적으로 적용하라면, 개발자들의 머릿속에 이 가이드라인이 잘 담겨있어야 한다!