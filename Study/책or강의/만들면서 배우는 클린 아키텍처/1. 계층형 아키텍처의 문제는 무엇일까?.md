![3tier-architecture](https://blog.kakaocdn.net/dn/L4n02/btrtieKhFOB/x18zXuuAzJNjFKc1vCx64k/img.png)
> 3Tier architecture; 상위 수준 관점에서 일반적인 3계층아키텍처

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다.

계층형 아키텍처는 코드에 나쁜 습관들이 스며들기 쉽게 만들고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다.

# 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.

모든 것이 영속성 계층을 토대로 만들어진다. 이런 방식은 다양한 이유로 문제를 초래한다.
- 우리는 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다.
- 어던 애플리케이션이든 상태가 중요한 요소이긴 하지만, 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다.
이때 우리는 `도메인 로직` 이 아닌 `데이터베이스`를 토대로 아키텍처를 만들어 나가게 된다.

> 전통형 아키텍처에서는 의존성의 방향에 따라 자연스럽게 도메인 로직보다 DB구조를 먼저 생각하고 구현하게 된다.
> 하지만 이는 *비즈니스 관점*에서는 전혀 맞지 않는 방법이다. 다른 무엇보다도 ==도메인 로직을 먼저 만들어야 한다.==

![도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다.](https://velog.velcdn.com/images/viewrain/post/3ab1e3f9-3773-4f66-969f-7f311a3aa1da/image.png)
ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다. 
계층은 아래 방향을 만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 수 있다.

하지만 이렇게 되면 <u>영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다</u>.
서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 ==도메인 로직 뿐만 아니라 영속성 계층과 관련된 작업들을 해야만 한다.==

# 지름길을 택하기 쉬워진다.

전통형 레이어드 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층만 접근 가능하다는 것이다.

![영속성 계층에서는 모든 것에 접근 가능하기 때문에 시간이 지나면서 점점 비대해진다.](https://velog.velcdn.com/images/viewrain/post/e8efff49-888b-48ae-bc8f-8855c4b30ec3/image.png)

영속성 계층은 수년에 걸친 개발과 유지보수로 결국 위와같이 될 확률이 많다. (점점 비대해진다.)

# 테스트하기 어려워진다.

![도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다.](https://velog.velcdn.com/images/viewrain/post/9fcc87e1-5187-476d-b03b-753ed38addc2/image.png)
계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다.
이런 일이 자주 일어나면 두가지 문제점이 생긴다.
1. 단 하나의 필드를 조작한다면 도메인 로직을 웹 계층에 구현해버리게 된다는것
2. 웹 계층 테스트에서 도메인 계층 뿐만 아니라, 영속성 계층도 모킹해야 한다는것.

영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트 복잡도를 높인다. 어느 순간에는 실제로 테스트 코드를 작성하는 것보다 종속성을 이해하고 목을 만드는 데 더 많은 시간이 걸리게 된다.

# 유스케이스를 숨긴다.

계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워진 상태다.

![넓은 서비스는 코드 상에서 특정 유스케이스를 찾는 것을 어렵게 만든다](https://velog.velcdn.com/images/viewrain/post/02e406b7-2101-4a65-b363-9b8816dfd192/image.png)
넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다. 

# 동시 작업이 어려워진다.

데이터베이스 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할 수 없다. 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기 더욱 어렵다.서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고, 이는 병합충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기한다.



